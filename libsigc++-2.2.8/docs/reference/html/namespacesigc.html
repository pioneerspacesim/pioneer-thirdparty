<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libsigc++: sigc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>sigc Namespace Reference</h1>
<p>The libsigc++ namespace. <a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1connection.html">connection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convinience class for safe disconnection. <a href="structsigc_1_1connection.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference wrapper. <a href="structsigc_1_1reference__wrapper.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reference wrapper. <a href="structsigc_1_1const__reference__wrapper.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1signal__base.html">signal_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the <a class="el" href="classsigc_1_1signal.html" title="Convenience wrapper for the numbered sigc::signal# templates.">sigc::signal</a># templates. <a href="structsigc_1_1signal__base.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1trackable.html">trackable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for objects with auto-disconnection. <a href="structsigc_1_1trackable.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1is__base__and__derived.html">is_base_and_derived</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time determination of base-class relationship in C++ (adapted to match the syntax of boost's type_traits library). <a href="structsigc_1_1is__base__and__derived.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__argument.html">bound_argument</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A bound_argument&lt;Foo&gt; object stores a bound (for instance, with <a class="el" href="group__bind.html#ga2148290d2cf9c1961ec157a085badd5a" title="Creates an adaptor of type sigc::bind_functor which binds the passed argument to...">sigc::bind()</a>, or <a class="el" href="group__bind.html#ga8a001b0bb588d2ac1af712781b89dc8a" title="Creates an adaptor of type sigc::bind_return_functor which fixes the return value...">sigc::bind_return()</a>) argument. <a href="classsigc_1_1bound__argument.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__argument_3_01reference__wrapper_3_01T__wrapped_01_4_01_4.html">bound_argument&lt; reference_wrapper&lt; T_wrapped &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__argument.html" title="A bound_argument&lt;Foo&gt; object stores a bound (for instance, with sigc::bind()...">bound_argument</a> object for a bound argument that is passed by <a class="el" href="group__bind.html#ga2148290d2cf9c1961ec157a085badd5a" title="Creates an adaptor of type sigc::bind_functor which binds the passed argument to...">bind()</a> or returned by <a class="el" href="group__bind.html#ga8a001b0bb588d2ac1af712781b89dc8a" title="Creates an adaptor of type sigc::bind_return_functor which fixes the return value...">bind_return()</a> by reference, specialized for reference_wrapper&lt;&gt; types. <a href="classsigc_1_1bound__argument_3_01reference__wrapper_3_01T__wrapped_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__argument_3_01const__reference__wrapper_3_01T__wrapped_01_4_01_4.html">bound_argument&lt; const_reference_wrapper&lt; T_wrapped &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__argument.html" title="A bound_argument&lt;Foo&gt; object stores a bound (for instance, with sigc::bind()...">bound_argument</a> object for a bound argument that is passed by <a class="el" href="group__bind.html#ga2148290d2cf9c1961ec157a085badd5a" title="Creates an adaptor of type sigc::bind_functor which binds the passed argument to...">bind()</a> or returned by <a class="el" href="group__bind.html#ga8a001b0bb588d2ac1af712781b89dc8a" title="Creates an adaptor of type sigc::bind_return_functor which fixes the return value...">bind_return()</a> by const reference, specialized for const reference_wrapper&lt;&gt; types. <a href="classsigc_1_1bound__argument_3_01const__reference__wrapper_3_01T__wrapped_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot__base.html">slot_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for slots. <a href="classsigc_1_1slot__base.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1slot__iterator.html">slot_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-style iterator for <a class="el" href="structsigc_1_1slot__list.html" title="STL-style list interface for sigc::signal#.">slot_list</a>. <a href="structsigc_1_1slot__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1slot__const__iterator.html">slot_const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-style const iterator for <a class="el" href="structsigc_1_1slot__list.html" title="STL-style list interface for sigc::signal#.">slot_list</a>. <a href="structsigc_1_1slot__const__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1slot__list.html">slot_list</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-style list interface for <a class="el" href="classsigc_1_1signal.html" title="Convenience wrapper for the numbered sigc::signal# templates.">sigc::signal</a>#. <a href="structsigc_1_1slot__list.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal0.html">signal0</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal1.html">signal1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal2.html">signal2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html">signal3</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal4.html">signal4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal5.html">signal5</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal6.html">signal6</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal7.html">signal7</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal.html">signal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal.html" title="Convenience wrapper for the numbered sigc::signal# templates.">sigc::signal</a># templates. <a href="classsigc_1_1signal.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt; T_return, nil, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal0.html" title="Signal declaration.">sigc::signal0</a> template. <a href="classsigc_1_1signal_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt; T_return, T_arg1, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal1.html" title="Signal declaration.">sigc::signal1</a> template. <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt; T_return, T_arg1, T_arg2, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal2.html" title="Signal declaration.">sigc::signal2</a> template. <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt; T_return, T_arg1, T_arg2, T_arg3, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal3.html" title="Signal declaration.">sigc::signal3</a> template. <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal4.html" title="Signal declaration.">sigc::signal4</a> template. <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html">signal&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal5.html" title="Signal declaration.">sigc::signal5</a> template. <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html">signal&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal6.html" title="Signal declaration.">sigc::signal6</a> template. <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1limit__reference.html">limit_reference</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a>, then <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a> reference instead of the derived reference. <a href="classsigc_1_1limit__reference.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1limit__reference_3_01T__type_00_01true_01_4.html">limit_reference&lt; T_type, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1limit__reference.html" title="A limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure...">limit_reference</a> object for a class that derives from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">trackable</a>. <a href="classsigc_1_1limit__reference_3_01T__type_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__limit__reference.html">const_limit_reference</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A const_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a>, then <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a> reference instead of the derived reference. <a href="classsigc_1_1const__limit__reference.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__limit__reference_3_01T__type_00_01true_01_4.html">const_limit_reference&lt; T_type, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__limit__reference.html" title="A const_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make...">const_limit_reference</a> object for a class that derives from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">trackable</a>. <a href="classsigc_1_1const__limit__reference_3_01T__type_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__limit__reference.html">volatile_limit_reference</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a>, then <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a> reference instead of the derived reference. <a href="classsigc_1_1volatile__limit__reference.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__limit__reference_3_01T__type_00_01true_01_4.html">volatile_limit_reference&lt; T_type, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__limit__reference.html" title="A volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make...">volatile_limit_reference</a> object for a class that derives from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">trackable</a>. <a href="classsigc_1_1volatile__limit__reference_3_01T__type_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__limit__reference.html">const_volatile_limit_reference</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A const_volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a>, then <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a> reference instead of the derived reference. <a href="classsigc_1_1const__volatile__limit__reference.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__limit__reference_3_01T__type_00_01true_01_4.html">const_volatile_limit_reference&lt; T_type, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__limit__reference.html" title="A const_volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;)...">const_volatile_limit_reference</a> object for a class that derives from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">trackable</a>. <a href="classsigc_1_1const__volatile__limit__reference_3_01T__type_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__base.html">functor_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A hint to the compiler. <a href="structsigc_1_1functor__base.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot0.html">slot0</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot1.html">slot1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot2.html">slot2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot3.html">slot3</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot4.html">slot4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot5.html">slot5</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot6.html">slot6</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot7.html">slot7</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot.html">slot</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot.html" title="Convenience wrapper for the numbered sigc::slot# templates.">sigc::slot</a># templates. <a href="classsigc_1_1slot.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt; T_return, nil, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">sigc::slot0</a> template. <a href="classsigc_1_1slot_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt; T_return, T_arg1, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">sigc::slot1</a> template. <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt; T_return, T_arg1, T_arg2, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">sigc::slot2</a> template. <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt; T_return, T_arg1, T_arg2, T_arg3, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">sigc::slot3</a> template. <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">sigc::slot4</a> template. <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html">slot&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">sigc::slot5</a> template. <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html">slot&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">sigc::slot6</a> template. <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor0.html" title="pointer_functor0 wraps existing non-member functions with 0 argument(s).">pointer_functor0</a> wraps existing non-member functions with 0 argument(s). <a href="classsigc_1_1pointer__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor1.html" title="pointer_functor1 wraps existing non-member functions with 1 argument(s).">pointer_functor1</a> wraps existing non-member functions with 1 argument(s). <a href="classsigc_1_1pointer__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor2.html" title="pointer_functor2 wraps existing non-member functions with 2 argument(s).">pointer_functor2</a> wraps existing non-member functions with 2 argument(s). <a href="classsigc_1_1pointer__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor3.html" title="pointer_functor3 wraps existing non-member functions with 3 argument(s).">pointer_functor3</a> wraps existing non-member functions with 3 argument(s). <a href="classsigc_1_1pointer__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor4.html" title="pointer_functor4 wraps existing non-member functions with 4 argument(s).">pointer_functor4</a> wraps existing non-member functions with 4 argument(s). <a href="classsigc_1_1pointer__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor5.html" title="pointer_functor5 wraps existing non-member functions with 5 argument(s).">pointer_functor5</a> wraps existing non-member functions with 5 argument(s). <a href="classsigc_1_1pointer__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor6.html" title="pointer_functor6 wraps existing non-member functions with 6 argument(s).">pointer_functor6</a> wraps existing non-member functions with 6 argument(s). <a href="classsigc_1_1pointer__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor7.html" title="pointer_functor7 wraps existing non-member functions with 7 argument(s).">pointer_functor7</a> wraps existing non-member functions with 7 argument(s). <a href="classsigc_1_1pointer__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">mem_functor0</a> wraps methods with 0 argument(s). <a href="classsigc_1_1mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">mem_functor1</a> wraps methods with 1 argument(s). <a href="classsigc_1_1mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">mem_functor2</a> wraps methods with 2 argument(s). <a href="classsigc_1_1mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">mem_functor3</a> wraps methods with 3 argument(s). <a href="classsigc_1_1mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">mem_functor4</a> wraps methods with 4 argument(s). <a href="classsigc_1_1mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">mem_functor5</a> wraps methods with 5 argument(s). <a href="classsigc_1_1mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">mem_functor6</a> wraps methods with 6 argument(s). <a href="classsigc_1_1mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">mem_functor7</a> wraps methods with 7 argument(s). <a href="classsigc_1_1mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor0.html" title="const_mem_functor0 wraps const methods with 0 argument(s).">const_mem_functor0</a> wraps const methods with 0 argument(s). <a href="classsigc_1_1const__mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor1.html" title="const_mem_functor1 wraps const methods with 1 argument(s).">const_mem_functor1</a> wraps const methods with 1 argument(s). <a href="classsigc_1_1const__mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor2.html" title="const_mem_functor2 wraps const methods with 2 argument(s).">const_mem_functor2</a> wraps const methods with 2 argument(s). <a href="classsigc_1_1const__mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor3.html" title="const_mem_functor3 wraps const methods with 3 argument(s).">const_mem_functor3</a> wraps const methods with 3 argument(s). <a href="classsigc_1_1const__mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor4.html" title="const_mem_functor4 wraps const methods with 4 argument(s).">const_mem_functor4</a> wraps const methods with 4 argument(s). <a href="classsigc_1_1const__mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor5.html" title="const_mem_functor5 wraps const methods with 5 argument(s).">const_mem_functor5</a> wraps const methods with 5 argument(s). <a href="classsigc_1_1const__mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor6.html" title="const_mem_functor6 wraps const methods with 6 argument(s).">const_mem_functor6</a> wraps const methods with 6 argument(s). <a href="classsigc_1_1const__mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor7.html" title="const_mem_functor7 wraps const methods with 7 argument(s).">const_mem_functor7</a> wraps const methods with 7 argument(s). <a href="classsigc_1_1const__mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor0.html" title="volatile_mem_functor0 wraps volatile methods with 0 argument(s).">volatile_mem_functor0</a> wraps volatile methods with 0 argument(s). <a href="classsigc_1_1volatile__mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor1.html" title="volatile_mem_functor1 wraps volatile methods with 1 argument(s).">volatile_mem_functor1</a> wraps volatile methods with 1 argument(s). <a href="classsigc_1_1volatile__mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor2.html" title="volatile_mem_functor2 wraps volatile methods with 2 argument(s).">volatile_mem_functor2</a> wraps volatile methods with 2 argument(s). <a href="classsigc_1_1volatile__mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor3.html" title="volatile_mem_functor3 wraps volatile methods with 3 argument(s).">volatile_mem_functor3</a> wraps volatile methods with 3 argument(s). <a href="classsigc_1_1volatile__mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor4.html" title="volatile_mem_functor4 wraps volatile methods with 4 argument(s).">volatile_mem_functor4</a> wraps volatile methods with 4 argument(s). <a href="classsigc_1_1volatile__mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor5.html" title="volatile_mem_functor5 wraps volatile methods with 5 argument(s).">volatile_mem_functor5</a> wraps volatile methods with 5 argument(s). <a href="classsigc_1_1volatile__mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor6.html" title="volatile_mem_functor6 wraps volatile methods with 6 argument(s).">volatile_mem_functor6</a> wraps volatile methods with 6 argument(s). <a href="classsigc_1_1volatile__mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor7.html" title="volatile_mem_functor7 wraps volatile methods with 7 argument(s).">volatile_mem_functor7</a> wraps volatile methods with 7 argument(s). <a href="classsigc_1_1volatile__mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html" title="const_volatile_mem_functor0 wraps const volatile methods with 0 argument(s).">const_volatile_mem_functor0</a> wraps const volatile methods with 0 argument(s). <a href="classsigc_1_1const__volatile__mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html" title="const_volatile_mem_functor1 wraps const volatile methods with 1 argument(s).">const_volatile_mem_functor1</a> wraps const volatile methods with 1 argument(s). <a href="classsigc_1_1const__volatile__mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html" title="const_volatile_mem_functor2 wraps const volatile methods with 2 argument(s).">const_volatile_mem_functor2</a> wraps const volatile methods with 2 argument(s). <a href="classsigc_1_1const__volatile__mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html" title="const_volatile_mem_functor3 wraps const volatile methods with 3 argument(s).">const_volatile_mem_functor3</a> wraps const volatile methods with 3 argument(s). <a href="classsigc_1_1const__volatile__mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html" title="const_volatile_mem_functor4 wraps const volatile methods with 4 argument(s).">const_volatile_mem_functor4</a> wraps const volatile methods with 4 argument(s). <a href="classsigc_1_1const__volatile__mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html" title="const_volatile_mem_functor5 wraps const volatile methods with 5 argument(s).">const_volatile_mem_functor5</a> wraps const volatile methods with 5 argument(s). <a href="classsigc_1_1const__volatile__mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html" title="const_volatile_mem_functor6 wraps const volatile methods with 6 argument(s).">const_volatile_mem_functor6</a> wraps const volatile methods with 6 argument(s). <a href="classsigc_1_1const__volatile__mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html" title="const_volatile_mem_functor7 wraps const volatile methods with 7 argument(s).">const_volatile_mem_functor7</a> wraps const volatile methods with 7 argument(s). <a href="classsigc_1_1const__volatile__mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance...">bound_mem_functor0</a> encapsulates a method with 0 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance...">bound_mem_functor1</a> encapsulates a method with 1 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance...">bound_mem_functor2</a> encapsulates a method with 2 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance...">bound_mem_functor3</a> encapsulates a method with 3 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance...">bound_mem_functor4</a> encapsulates a method with 4 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance...">bound_mem_functor5</a> encapsulates a method with 5 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance...">bound_mem_functor6</a> encapsulates a method with 6 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance...">bound_mem_functor7</a> encapsulates a method with 7 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object...">bound_const_mem_functor0</a> encapsulates a const method with 0 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object...">bound_const_mem_functor1</a> encapsulates a const method with 1 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object...">bound_const_mem_functor2</a> encapsulates a const method with 2 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object...">bound_const_mem_functor3</a> encapsulates a const method with 3 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object...">bound_const_mem_functor4</a> encapsulates a const method with 4 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object...">bound_const_mem_functor5</a> encapsulates a const method with 5 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object...">bound_const_mem_functor6</a> encapsulates a const method with 6 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object...">bound_const_mem_functor7</a> encapsulates a const method with 7 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an...">bound_volatile_mem_functor0</a> encapsulates a volatile method with 0 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an...">bound_volatile_mem_functor1</a> encapsulates a volatile method with 1 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an...">bound_volatile_mem_functor2</a> encapsulates a volatile method with 2 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an...">bound_volatile_mem_functor3</a> encapsulates a volatile method with 3 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an...">bound_volatile_mem_functor4</a> encapsulates a volatile method with 4 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an...">bound_volatile_mem_functor5</a> encapsulates a volatile method with 5 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an...">bound_volatile_mem_functor6</a> encapsulates a volatile method with 6 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an...">bound_volatile_mem_functor7</a> encapsulates a volatile method with 7 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments...">bound_const_volatile_mem_functor0</a> encapsulates a const volatile method with 0 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments...">bound_const_volatile_mem_functor1</a> encapsulates a const volatile method with 1 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments...">bound_const_volatile_mem_functor2</a> encapsulates a const volatile method with 2 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments...">bound_const_volatile_mem_functor3</a> encapsulates a const volatile method with 3 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments...">bound_const_volatile_mem_functor4</a> encapsulates a const volatile method with 4 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments...">bound_const_volatile_mem_functor5</a> encapsulates a const volatile method with 5 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments...">bound_const_volatile_mem_functor6</a> encapsulates a const volatile method with 6 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments...">bound_const_volatile_mem_functor7</a> encapsulates a const volatile method with 7 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adaptor__base.html">adaptor_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A hint to the compiler. <a href="structsigc_1_1adaptor__base.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type.html">deduce_result_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01void_00_01void_00_01void_00_01void_00_01vdb2f9f83b3eba2baeb19678a790211a3.html">deduce_result_type&lt; T_functor, void, void, void, void, void, void, void, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01void_00_01void_00_01void_00_01void_00_01vdb2f9f83b3eba2baeb19678a790211a3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01void_00_01void_00_01void_00_f4c559613b292c7b689426d5c155df15.html">deduce_result_type&lt; T_functor, T_arg1, void, void, void, void, void, void, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01void_00_01void_00_01void_00_f4c559613b292c7b689426d5c155df15.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01void_00_01void_724dd7c759e838f48e6fa6545d8e015d.html">deduce_result_type&lt; T_functor, T_arg1, T_arg2, void, void, void, void, void, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01void_00_01void_724dd7c759e838f48e6fa6545d8e015d.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01vo258d7260cbbb4e192063ff2984a0677a.html">deduce_result_type&lt; T_functor, T_arg1, T_arg2, T_arg3, void, void, void, void, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01vo258d7260cbbb4e192063ff2984a0677a.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_9b37fe7be1f2633448bc6b77ab8f97ff.html">deduce_result_type&lt; T_functor, T_arg1, T_arg2, T_arg3, T_arg4, void, void, void, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_9b37fe7be1f2633448bc6b77ab8f97ff.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_d8ef7847af7e7170bed8f3a632586811.html">deduce_result_type&lt; T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, void, void, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_d8ef7847af7e7170bed8f3a632586811.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_4788a98c68901ad51b4daf97aed5e129.html">deduce_result_type&lt; T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, void, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_4788a98c68901ad51b4daf97aed5e129.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_5c3a161eb5dba3c597d379b0bd504e5f.html">deduce_result_type&lt; T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_5c3a161eb5dba3c597d379b0bd504e5f.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adaptor__functor.html">adaptor_functor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor into an adaptor type. <a href="structsigc_1_1adaptor__functor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adapts.html">adapts</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for adaptors. <a href="structsigc_1_1adapts.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_010_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt; 0, T_functor, T_bound, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. <a href="structsigc_1_1bind__functor_3_010_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_011_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt; 1, T_functor, T_bound, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. <a href="structsigc_1_1bind__functor_3_011_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_012_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt; 2, T_functor, T_bound, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. <a href="structsigc_1_1bind__functor_3_012_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_013_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt; 3, T_functor, T_bound, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. <a href="structsigc_1_1bind__functor_3_013_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_014_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt; 4, T_functor, T_bound, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. <a href="structsigc_1_1bind__functor_3_014_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_015_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt; 5, T_functor, T_bound, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. <a href="structsigc_1_1bind__functor_3_015_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_016_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt; 6, T_functor, T_bound, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. <a href="structsigc_1_1bind__functor_3_016_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt;-1, T_functor, T_type1, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds 1 argument(s) to the wrapped functor. <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds 2 argument(s) to the wrapped functor. <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01n6d14effad731c8dfead9984e87967108.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, nil, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds 3 argument(s) to the wrapped functor. <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01n6d14effad731c8dfead9984e87967108.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T8abd615cc403946700f41917bb90042c.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, nil, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds 4 argument(s) to the wrapped functor. <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T8abd615cc403946700f41917bb90042c.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01Tf230465d8da8d21a2da815d7eb05b413.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, nil, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds 5 argument(s) to the wrapped functor. <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01Tf230465d8da8d21a2da815d7eb05b413.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T5d526f12c92849dac4a70f282eec9dc2.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, nil &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds 6 argument(s) to the wrapped functor. <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T5d526f12c92849dac4a70f282eec9dc2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T1564029be5092b4f54029884f8072971.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds 7 argument(s) to the wrapped functor. <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T1564029be5092b4f54029884f8072971.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__return__functor.html">bind_return_functor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that fixes the return value of the wrapped functor. <a href="structsigc_1_1bind__return__functor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that perform a C-style cast on the return value of a functor. <a href="structsigc_1_1retype__return__functor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1retype__return__functor_3_01void_00_01T__functor_01_4.html">retype_return_functor&lt; void, T_functor &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that perform a C-style cast on the return value of a functor. <a href="structsigc_1_1retype__return__functor_3_01void_00_01T__functor_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3-1_00_01T__functor_01_4.html">hide_functor&lt;-1, T_functor &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3-1_00_01T__functor_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_010_00_01T__functor_01_4.html">hide_functor&lt; 0, T_functor &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3_010_00_01T__functor_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_011_00_01T__functor_01_4.html">hide_functor&lt; 1, T_functor &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3_011_00_01T__functor_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_012_00_01T__functor_01_4.html">hide_functor&lt; 2, T_functor &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3_012_00_01T__functor_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_013_00_01T__functor_01_4.html">hide_functor&lt; 3, T_functor &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3_013_00_01T__functor_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_014_00_01T__functor_01_4.html">hide_functor&lt; 4, T_functor &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3_014_00_01T__functor_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_015_00_01T__functor_01_4.html">hide_functor&lt; 5, T_functor &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3_015_00_01T__functor_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_016_00_01T__functor_01_4.html">hide_functor&lt; 6, T_functor &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3_016_00_01T__functor_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that performs C-style casts on the parameters passed on to the functor. <a href="structsigc_1_1retype__functor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1compose1__functor.html">compose1_functor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that combines two functors. <a href="structsigc_1_1compose1__functor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1compose2__functor.html">compose2_functor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that combines three functors. <a href="structsigc_1_1compose2__functor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__base.html">lambda_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A hint to the compiler. <a href="structsigc_1_1lambda__base.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda.html">lambda</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lambda type. <a href="structsigc_1_1lambda.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the type of the object stored in an object of the passed <a class="el" href="structsigc_1_1lambda.html" title="Lambda type.">lambda</a> type. <a href="structsigc_1_1unwrap__lambda__type.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait.html">dereference_trait</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the base type of a reference or a pointer. <a href="structsigc_1_1dereference__trait.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a>&lt; T_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ad6e63f1697c807728f518f21f69e1931">ref</a> (T_type&amp; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reference wrapper. <a href="#ad6e63f1697c807728f518f21f69e1931"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a>&lt; T_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a70808607392abfe36e726a7d7a455b54">ref</a> (const T_type&amp; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a const reference wrapper. <a href="#a70808607392abfe36e726a7d7a455b54"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9ab34595691ae106045ce14a4c39c475"></a><!-- doxytag: member="sigc::unwrap" ref="a9ab34595691ae106045ce14a4c39c475" args="(const reference_wrapper&lt; T_type &gt; &amp;v)" -->
template &lt;class T_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T_type&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unwrap</b> (const <a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a>&lt; T_type &gt;&amp; v)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a80818400f4a09973ac095c8d59d613be"></a><!-- doxytag: member="sigc::unwrap" ref="a80818400f4a09973ac095c8d59d613be" args="(const const_reference_wrapper&lt; T_type &gt; &amp;v)" -->
template &lt;class T_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const T_type&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unwrap</b> (const <a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a>&lt; T_type &gt;&amp; v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541">visit_each</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor. <a href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5c455eda401dee43de931c24ad45d445"></a><!-- doxytag: member="sigc::visit_each_type" ref="ga5c455eda401dee43de931c24ad45d445" args="(const T_action &amp;_A_action, const T_functor &amp;_A_functor)" -->
template &lt;class T_type , class T_action , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#ga5c455eda401dee43de931c24ad45d445">visit_each_type</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor limited to a restricted type. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a78af6ff8fb24c17f5e72fd36d0be7975">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__argument.html">bound_argument</a>&lt; T_type &gt;&amp; _A_argument)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1bound__argument.html" title="A bound_argument&lt;Foo&gt; object stores a bound (for instance, with sigc::bind()...">bound_argument</a> class. <a href="#a78af6ff8fb24c17f5e72fd36d0be7975"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_type , bool I_derives_trackable&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a45fbeeeed09915ba6eac52d8c0e6f601">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1limit__reference.html">limit_reference</a>&lt; T_type, I_derives_trackable &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1limit__reference.html" title="A limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure...">limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the limit_reference's visit() method. <a href="#a45fbeeeed09915ba6eac52d8c0e6f601"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_type , bool I_derives_trackable&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a3d6923539508a182c7c0f2cd14f7da76">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1const__limit__reference.html">const_limit_reference</a>&lt; T_type, I_derives_trackable &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1const__limit__reference.html" title="A const_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make...">const_limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the const_limit_reference's visit() method. <a href="#a3d6923539508a182c7c0f2cd14f7da76"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_type , bool I_derives_trackable&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a6d8d4ebf03d12349254c840b6abeab1b">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1volatile__limit__reference.html">volatile_limit_reference</a>&lt; T_type, I_derives_trackable &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1volatile__limit__reference.html" title="A volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make...">volatile_limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the volatile_limit_reference's visit() method. <a href="#a6d8d4ebf03d12349254c840b6abeab1b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_type , bool I_derives_trackable&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a0729e10eaf72affb56a48c20f7197009">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1const__volatile__limit__reference.html">const_volatile_limit_reference</a>&lt; T_type, I_derives_trackable &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1const__volatile__limit__reference.html" title="A const_volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;)...">const_volatile_limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the const_volatile_limit_reference's visit() method. <a href="#a0729e10eaf72affb56a48c20f7197009"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt; T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gad9b9e60a02af51249293093877d12366">ptr_fun0</a> (T_return(* _A_func)())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor0.html" title="pointer_functor0 wraps existing non-member functions with 0 argument(s).">sigc::pointer_functor0</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#gad9b9e60a02af51249293093877d12366"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga0b111edc3fc4c7d7a50a715378033b1c">ptr_fun1</a> (T_return(* _A_func)(T_arg1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor1.html" title="pointer_functor1 wraps existing non-member functions with 1 argument(s).">sigc::pointer_functor1</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga0b111edc3fc4c7d7a50a715378033b1c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gaef724f617646c2f210056f17f109568b">ptr_fun2</a> (T_return(* _A_func)(T_arg1, T_arg2))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor2.html" title="pointer_functor2 wraps existing non-member functions with 2 argument(s).">sigc::pointer_functor2</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#gaef724f617646c2f210056f17f109568b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gacd506872e7b72dcfa12251afc0c8ff3d">ptr_fun3</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor3.html" title="pointer_functor3 wraps existing non-member functions with 3 argument(s).">sigc::pointer_functor3</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#gacd506872e7b72dcfa12251afc0c8ff3d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga8656c2f98274ed8b77fed96b8b332856">ptr_fun4</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor4.html" title="pointer_functor4 wraps existing non-member functions with 4 argument(s).">sigc::pointer_functor4</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga8656c2f98274ed8b77fed96b8b332856"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga6c3e7322ef8daea0715a38b9414e2230">ptr_fun5</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor5.html" title="pointer_functor5 wraps existing non-member functions with 5 argument(s).">sigc::pointer_functor5</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga6c3e7322ef8daea0715a38b9414e2230"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga676225a4bfa6ac02f1ef75df88668177">ptr_fun6</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor6.html" title="pointer_functor6 wraps existing non-member functions with 6 argument(s).">sigc::pointer_functor6</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga676225a4bfa6ac02f1ef75df88668177"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga70b52b1aaf2e0c5c8ad3ea3d8ca0dd01">ptr_fun7</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor7.html" title="pointer_functor7 wraps existing non-member functions with 7 argument(s).">sigc::pointer_functor7</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga70b52b1aaf2e0c5c8ad3ea3d8ca0dd01"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt; T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gada8b678665c14dc85eb32d25b7299465">ptr_fun</a> (T_return(* _A_func)())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor0.html" title="pointer_functor0 wraps existing non-member functions with 0 argument(s).">sigc::pointer_functor0</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#gada8b678665c14dc85eb32d25b7299465"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga9b28ec630d156c9251de7dd12139671f">ptr_fun</a> (T_return(* _A_func)(T_arg1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor1.html" title="pointer_functor1 wraps existing non-member functions with 1 argument(s).">sigc::pointer_functor1</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga9b28ec630d156c9251de7dd12139671f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gaba004f27180eedd3c9d1078e301e3060">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor2.html" title="pointer_functor2 wraps existing non-member functions with 2 argument(s).">sigc::pointer_functor2</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#gaba004f27180eedd3c9d1078e301e3060"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga1f24d43677b44f38d295ba11a2cc7499">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor3.html" title="pointer_functor3 wraps existing non-member functions with 3 argument(s).">sigc::pointer_functor3</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga1f24d43677b44f38d295ba11a2cc7499"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga32bb99818a7751f420b03bf8875a0fe2">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor4.html" title="pointer_functor4 wraps existing non-member functions with 4 argument(s).">sigc::pointer_functor4</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga32bb99818a7751f420b03bf8875a0fe2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga395fc9ec71fad6436a22839c37da55ea">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor5.html" title="pointer_functor5 wraps existing non-member functions with 5 argument(s).">sigc::pointer_functor5</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga395fc9ec71fad6436a22839c37da55ea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga1a121903549ba2cc9c51ed12ffb2bd6b">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor6.html" title="pointer_functor6 wraps existing non-member functions with 6 argument(s).">sigc::pointer_functor6</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga1a121903549ba2cc9c51ed12ffb2bd6b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga5698f61c40d344caee83860b0bf1b021">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor7.html" title="pointer_functor7 wraps existing non-member functions with 7 argument(s).">sigc::pointer_functor7</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga5698f61c40d344caee83860b0bf1b021"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga8a0e4bdca79dde7347318bff4d6e1eda">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga8a0e4bdca79dde7347318bff4d6e1eda"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaff3264460325cf2a34cc0502fec7b8b7">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gaff3264460325cf2a34cc0502fec7b8b7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga497c57551529e8721861cedc1c3d5121">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga497c57551529e8721861cedc1c3d5121"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga5cc57f71faadc4101e7a10e0b5d7317f">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga5cc57f71faadc4101e7a10e0b5d7317f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga66608a108aa332faf3c3bfd418655fcb">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga66608a108aa332faf3c3bfd418655fcb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaee9534127cddea3f7b3e5461f768a42b">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gaee9534127cddea3f7b3e5461f768a42b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga259c308cca0572400aaed34384eafbe3">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga259c308cca0572400aaed34384eafbe3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga56f7d4d8f86928edb83e1f65702a2978">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga56f7d4d8f86928edb83e1f65702a2978"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaa0d89783277d6e9dede11eda2ff6c75a">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gaa0d89783277d6e9dede11eda2ff6c75a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga20b2c11c8fb2a9e0bb86ad4c66c9c2e7">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga20b2c11c8fb2a9e0bb86ad4c66c9c2e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga8ef4b45b1dcecb9270562c030e38e339">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga8ef4b45b1dcecb9270562c030e38e339"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaa3c16c17557fcebdd7573fa6b2ed0dcf">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gaa3c16c17557fcebdd7573fa6b2ed0dcf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga6bbf2084c41ca86d2ab99e21adf28f30">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga6bbf2084c41ca86d2ab99e21adf28f30"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga21e843c71a56dba1d507c9a92fad48d1">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga21e843c71a56dba1d507c9a92fad48d1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga5af2a45e22e6f53837fa0b5f9de0ad57">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga5af2a45e22e6f53837fa0b5f9de0ad57"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf8ba948d4075a160a3c887d5bc29fe38">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gaf8ba948d4075a160a3c887d5bc29fe38"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga167fc8e84727e8b465c5f569da18fe7c">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga167fc8e84727e8b465c5f569da18fe7c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac99d35f92c4859d7ba58c0f8dbee8a59">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gac99d35f92c4859d7ba58c0f8dbee8a59"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafd990e80dc9ec40599b0e66526334ed3">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gafd990e80dc9ec40599b0e66526334ed3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga8df64a5ef08edf9a3bffd45888cf6566">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga8df64a5ef08edf9a3bffd45888cf6566"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga115420b91c53ff373128c8d9c5389e26">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga115420b91c53ff373128c8d9c5389e26"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga59db8f4f6bf774aac7a42e4db22fe525">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga59db8f4f6bf774aac7a42e4db22fe525"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4fe42d39978e3534528e704a2ef69d19">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga4fe42d39978e3534528e704a2ef69d19"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaed1e318f76b0b4560f7f7f15348bf74f">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gaed1e318f76b0b4560f7f7f15348bf74f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga7f0b3a137305d0da984cfcaa69028645">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga7f0b3a137305d0da984cfcaa69028645"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafa45bea25d6b97dd4215c61845eb276b">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gafa45bea25d6b97dd4215c61845eb276b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga8bbfab43840801b698deebdbcced31b8">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga8bbfab43840801b698deebdbcced31b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4e8a4b740ba229328323782cdff5defc">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga4e8a4b740ba229328323782cdff5defc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gae32dedba98d5616ffed3bf45564b5925">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gae32dedba98d5616ffed3bf45564b5925"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga0a7438643be599bd0687c6de6af6ec2b">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga0a7438643be599bd0687c6de6af6ec2b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gacb29a90ac86fe224d4074619e0117cb8">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gacb29a90ac86fe224d4074619e0117cb8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaaa2493ee4790a02fad2dfd44e3e4e1f6">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gaaa2493ee4790a02fad2dfd44e3e4e1f6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gad6f8ec28efe46a939923e0ae83aa2888">mem_fun0</a> (T_return(T_obj::* _A_func)())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">sigc::mem_functor0</a> which wraps a method. <a href="group__mem__fun.html#gad6f8ec28efe46a939923e0ae83aa2888"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac54cbcf11289d7b7fe15dff1fc2e84f4">mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">sigc::mem_functor1</a> which wraps a method. <a href="group__mem__fun.html#gac54cbcf11289d7b7fe15dff1fc2e84f4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga353bb1c7c03796bafe5ed2e52f012980">mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">sigc::mem_functor2</a> which wraps a method. <a href="group__mem__fun.html#ga353bb1c7c03796bafe5ed2e52f012980"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaa603c1c92cc9140a13d89256724de663">mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">sigc::mem_functor3</a> which wraps a method. <a href="group__mem__fun.html#gaa603c1c92cc9140a13d89256724de663"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga9e5cce0968f3f2a79240922ebc1b6745">mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">sigc::mem_functor4</a> which wraps a method. <a href="group__mem__fun.html#ga9e5cce0968f3f2a79240922ebc1b6745"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab0cbec1f295cbf8283208dedf5ab9ac7">mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">sigc::mem_functor5</a> which wraps a method. <a href="group__mem__fun.html#gab0cbec1f295cbf8283208dedf5ab9ac7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1c9c46a46db3d5d01d582b6867665c7c">mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">sigc::mem_functor6</a> which wraps a method. <a href="group__mem__fun.html#ga1c9c46a46db3d5d01d582b6867665c7c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafb7d7c8968bebcfea74f08c3eb55b14f">mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">sigc::mem_functor7</a> which wraps a method. <a href="group__mem__fun.html#gafb7d7c8968bebcfea74f08c3eb55b14f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gae75bc5b94c36e78775ff5b5f20767baf">mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gae75bc5b94c36e78775ff5b5f20767baf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3d62fea84f3f77ac5a315cebe5286b47">mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga3d62fea84f3f77ac5a315cebe5286b47"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gabb30783d2b0ac099089d70274d4459fb">mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gabb30783d2b0ac099089d70274d4459fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf19bbb21b4b903e1a6b97fea87e90663">mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gaf19bbb21b4b903e1a6b97fea87e90663"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab1a00dd97f2ca5e21b2b4f73fea4053b">mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gab1a00dd97f2ca5e21b2b4f73fea4053b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaa34194e868680c9146f8d143ddbdd8a8">mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gaa34194e868680c9146f8d143ddbdd8a8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4908458d042d70f91be5f72547518e4f">mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga4908458d042d70f91be5f72547518e4f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga750c42aaea61ec588daf64d4111e8429">mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga750c42aaea61ec588daf64d4111e8429"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac725cb282b0c611c67a270a7821e173f">mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gac725cb282b0c611c67a270a7821e173f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga211bd1f151b5936a549a8d8e6ab911bf">mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga211bd1f151b5936a549a8d8e6ab911bf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga55aafe144e22f4df7fe785c1eec839ca">mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga55aafe144e22f4df7fe785c1eec839ca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3b7fd6101534e982aa29c0308ce69006">mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga3b7fd6101534e982aa29c0308ce69006"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadedf83e65a2aca0d3aa4ac0b6d68ccd8">mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gadedf83e65a2aca0d3aa4ac0b6d68ccd8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga61cec9d9ec3d399f0d14a3b2edb6fecc">mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga61cec9d9ec3d399f0d14a3b2edb6fecc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf6a1bce5fc8d6a117124874f2fa6ab18">mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gaf6a1bce5fc8d6a117124874f2fa6ab18"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga208d42856768ebe922a1418f7250ca31">mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga208d42856768ebe922a1418f7250ca31"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga7d9ea809173f48bf5c76cf1989591602">mem_fun</a> (T_return(T_obj::* _A_func)())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">sigc::mem_functor0</a> which wraps a method. <a href="group__mem__fun.html#ga7d9ea809173f48bf5c76cf1989591602"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafa7e13948472a451e25485f2c5001028">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">sigc::mem_functor1</a> which wraps a method. <a href="group__mem__fun.html#gafa7e13948472a451e25485f2c5001028"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga13a02e1edfe8b4450aba9f9629c69183">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">sigc::mem_functor2</a> which wraps a method. <a href="group__mem__fun.html#ga13a02e1edfe8b4450aba9f9629c69183"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga8a171185d53c5ef87adb18bdd1d34aca">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">sigc::mem_functor3</a> which wraps a method. <a href="group__mem__fun.html#ga8a171185d53c5ef87adb18bdd1d34aca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga17d792c86d3251c2045987c4dec04494">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">sigc::mem_functor4</a> which wraps a method. <a href="group__mem__fun.html#ga17d792c86d3251c2045987c4dec04494"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga72ce5f7bfd24897f48d0ebd676bcbe5a">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">sigc::mem_functor5</a> which wraps a method. <a href="group__mem__fun.html#ga72ce5f7bfd24897f48d0ebd676bcbe5a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadbb4cac2850f0f61f6d5f9e17e02c7ba">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">sigc::mem_functor6</a> which wraps a method. <a href="group__mem__fun.html#gadbb4cac2850f0f61f6d5f9e17e02c7ba"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf995826321b8808ce8839e4abbb0550d">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">sigc::mem_functor7</a> which wraps a method. <a href="group__mem__fun.html#gaf995826321b8808ce8839e4abbb0550d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga51fa4e5052666f6738abbaa628ec6cc2">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga51fa4e5052666f6738abbaa628ec6cc2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gae53b7ef4bd43363998aff8a589bc254a">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gae53b7ef4bd43363998aff8a589bc254a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga47ec248386b6998e5f8b9a80191e4d5d">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga47ec248386b6998e5f8b9a80191e4d5d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga6e58e3cf7e4f1b5fbcb85736369d018c">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga6e58e3cf7e4f1b5fbcb85736369d018c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1b200788ce261aef52a8dadaa1e2c9aa">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga1b200788ce261aef52a8dadaa1e2c9aa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga81b830d633d756ca945bac75c4b2f8e8">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga81b830d633d756ca945bac75c4b2f8e8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga975cacf1b6fdd69a93c2f5ba0973f780">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga975cacf1b6fdd69a93c2f5ba0973f780"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab37fdbceea44a66560bb16345e1593e6">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gab37fdbceea44a66560bb16345e1593e6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadd76171e23f2e904c7f01264228440fc">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gadd76171e23f2e904c7f01264228440fc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga23120ad94420b72a8761423c5bab2bec">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga23120ad94420b72a8761423c5bab2bec"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga34e7257908fb33b2582f686ac51e1d74">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga34e7257908fb33b2582f686ac51e1d74"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac41f442c5e8a533e98cce0d7df02efe6">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gac41f442c5e8a533e98cce0d7df02efe6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab1b6c289aa5b68e382c259bb5c35aa95">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gab1b6c289aa5b68e382c259bb5c35aa95"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga8fbf4b5621eda8f79ba2be75bd7badd4">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga8fbf4b5621eda8f79ba2be75bd7badd4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafc3676e579d8e7b037c0589b2ab12270">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gafc3676e579d8e7b037c0589b2ab12270"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gacdcec06e66f0ba9a970e530c953d60b6">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gacdcec06e66f0ba9a970e530c953d60b6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__adaptors.html#gafb822cac23e9bf97c164793a36246d5c">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1adaptor__functor.html">adaptor_functor</a>&lt; T_functor &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__adaptors.html#gafb822cac23e9bf97c164793a36246d5c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , int T_loc, class T_functor , class T_bound &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gaed4a6aaa9d804f82fd558d553b67c3a8">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt; T_loc, T_functor, T_bound &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#gaed4a6aaa9d804f82fd558d553b67c3a8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga97d5feac063beaf49157990f98aad6fe">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#ga97d5feac063beaf49157990f98aad6fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 , class T_type2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gaca2e99785599f7631337d5fbbecbc610">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#gaca2e99785599f7631337d5fbbecbc610"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 , class T_type2 , class T_type3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gab9bc9f3ffe4a706128948eb00751eadc">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#gab9bc9f3ffe4a706128948eb00751eadc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 , class T_type2 , class T_type3 , class T_type4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gaa60aa29a584517ad422473281ce2864b">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#gaa60aa29a584517ad422473281ce2864b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga5237d6d834423536367bf130760e88b3">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#ga5237d6d834423536367bf130760e88b3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 , class T_type6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga5017f20f5c99a9a1007476a397e6b0af">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#ga5017f20f5c99a9a1007476a397e6b0af"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 , class T_type6 , class T_type7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gab7f865e06297273a2b5d80b7d7865bdb">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#gab7f865e06297273a2b5d80b7d7865bdb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int I_location, class T_bound1 , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bind_functor&lt; I_location, <br class="typebreak"/>
T_functor, T_bound1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga2148290d2cf9c1961ec157a085badd5a">bind</a> (const T_functor&amp; _A_func, T_bound1 _A_b1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which binds the passed argument to the passed functor. <a href="group__bind.html#ga2148290d2cf9c1961ec157a085badd5a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bind_functor&lt;-1, T_functor, <br class="typebreak"/>
T_type1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga5858818e62c9df7ded906d9461d012cd">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 1 argument(s) of the passed functor. <a href="group__bind.html#ga5858818e62c9df7ded906d9461d012cd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bind_functor&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga68057ec737e31fa433a0a5f726f27cd1">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 2 argument(s) of the passed functor. <a href="group__bind.html#ga68057ec737e31fa433a0a5f726f27cd1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_type3 , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bind_functor&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2, T_type3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga006c34f47e2a19358be290d438c0de19">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 3 argument(s) of the passed functor. <a href="group__bind.html#ga006c34f47e2a19358be290d438c0de19"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bind_functor&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2, T_type3, <br class="typebreak"/>
T_type4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gaafb060da662d2ab98bf377c16a5df8f4">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 4 argument(s) of the passed functor. <a href="group__bind.html#gaafb060da662d2ab98bf377c16a5df8f4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bind_functor&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2, T_type3, <br class="typebreak"/>
T_type4, T_type5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gae20edab579c98fecb975a5cc698d8ab2">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 5 argument(s) of the passed functor. <a href="group__bind.html#gae20edab579c98fecb975a5cc698d8ab2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 , class T_type6 , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bind_functor&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2, T_type3, <br class="typebreak"/>
T_type4, T_type5, T_type6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga7f4b6bd72965b7840fa5b518e0d069c1">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5, T_type6 _A_b6)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 6 argument(s) of the passed functor. <a href="group__bind.html#ga7f4b6bd72965b7840fa5b518e0d069c1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 , class T_type6 , class T_type7 , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bind_functor&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2, T_type3, <br class="typebreak"/>
T_type4, T_type5, T_type6, <br class="typebreak"/>
T_type7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga356da93520385d48f66125257d2b8f2b">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5, T_type6 _A_b6, T_type7 _A_b7)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 7 argument(s) of the passed functor. <a href="group__bind.html#ga356da93520385d48f66125257d2b8f2b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga27e8bea76ba380b8223b059369b2c485">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1bind__return__functor.html">bind_return_functor</a>&lt; T_return, T_functor &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#ga27e8bea76ba380b8223b059369b2c485"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1bind__return__functor.html">bind_return_functor</a>&lt; T_return, <br class="typebreak"/>
T_functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga8a001b0bb588d2ac1af712781b89dc8a">bind_return</a> (const T_functor&amp; _A_functor, T_return _A_ret_value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1bind__return__functor.html" title="Adaptor that fixes the return value of the wrapped functor.">sigc::bind_return_functor</a> which fixes the return value of the passed functor to the passed argument. <a href="group__bind.html#ga8a001b0bb588d2ac1af712781b89dc8a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gad33e9950e9acacd8d6817494f43b7f6d">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a>&lt; T_return, T_functor &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__retype.html#gad33e9950e9acacd8d6817494f43b7f6d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a><br class="typebreak"/>
&lt; T_return, T_functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga263b14f3b0e5616cd3b870d78a2627fa">retype_return</a> (const T_functor&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__return__functor.html" title="Adaptor that perform a C-style cast on the return value of a functor.">sigc::retype_return_functor</a> which performs a C-style cast on the return value of the passed functor. <a href="group__retype.html#ga263b14f3b0e5616cd3b870d78a2627fa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a>&lt; void, <br class="typebreak"/>
T_functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hide.html#gad7e18e1edbbefe13216eb344bd522f0a">hide_return</a> (const T_functor&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__return__functor.html" title="Adaptor that perform a C-style cast on the return value of a functor.">sigc::retype_return_functor</a> which drops the return value of the passed functor. <a href="group__hide.html#gad7e18e1edbbefe13216eb344bd522f0a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , int I_location, class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hide.html#gaa07f0ffec52a12cd7dcf1601938b247c">visit_each</a> (const T_action&amp; _A_action, const hide_functor&lt; I_location, T_functor &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__hide.html#gaa07f0ffec52a12cd7dcf1601938b247c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int I_location, class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">hide_functor&lt; I_location, <br class="typebreak"/>
T_functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hide.html#gaf28d43958b26c67e314f726540463c44">hide</a> (const T_functor&amp; _A_func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::hide_functor which adds a dummy parameter to the passed functor. <a href="group__hide.html#gaf28d43958b26c67e314f726540463c44"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">hide_functor&lt;-1, T_functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaf28d43958b26c67e314f726540463c44">hide</a> (const T_functor&amp; _A_func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::hide_functor which adds a dummy parameter to the passed functor. <a href="#gaf28d43958b26c67e314f726540463c44"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 , class T_type6 , class T_type7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaf94761944ad0dbd50e8b933adb07db33">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__retype.html#gaf94761944ad0dbd50e8b933adb07db33"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1slot.html">slot</a>&lt; T_return, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6, T_arg7 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gafd118b8e28ec60f260d8182c0552f9b2">retype</a> (const <a class="el" href="classsigc_1_1slot.html">slot</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gafd118b8e28ec60f260d8182c0552f9b2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt; T_return &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gae7d8cd2a8fba2a4eccf2bed45a52bcee">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt; T_return &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gae7d8cd2a8fba2a4eccf2bed45a52bcee"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1, <br class="typebreak"/>
T_return &gt;, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga43bcf770d8f32c0863ab49eca05e9e55">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1, T_return &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga43bcf770d8f32c0863ab49eca05e9e55"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_return &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga50a2eeb831e4bfd1917ac230b38fb8eb">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1, T_arg2, T_return &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga50a2eeb831e4bfd1917ac230b38fb8eb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_return &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga45c2dc65def352bca7b44e7e81e108cf">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1, T_arg2, T_arg3, T_return &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga45c2dc65def352bca7b44e7e81e108cf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_return &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gafaadd09afe1b8f15f117e6370273f736">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1, T_arg2, T_arg3, T_arg4, T_return &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gafaadd09afe1b8f15f117e6370273f736"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_return &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga0b7b036e5d1c43c48cb5b53b0e68d60d">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga0b7b036e5d1c43c48cb5b53b0e68d60d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_return &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaaccd5f7ab8c3e54b4b3a22522a7d10f3">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaaccd5f7ab8c3e54b4b3a22522a7d10f3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7, T_return &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga373c281861b873261d948a6c69fd2d71">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga373c281861b873261d948a6c69fd2d71"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga48a60c1ad878688272cbb00ced921fff">retype</a> (const <a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga48a60c1ad878688272cbb00ced921fff"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga9f3cf52bbddcd3ddb733e15a52219945">retype</a> (const <a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga9f3cf52bbddcd3ddb733e15a52219945"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaab837288b46afaea8d688c069a1d4d7b">retype</a> (const <a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaab837288b46afaea8d688c069a1d4d7b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga5e89fecccca95672490dba52a88507ae">retype</a> (const <a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga5e89fecccca95672490dba52a88507ae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga636d9880aa19a7cac34d46dd0be3bea3">retype</a> (const <a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga636d9880aa19a7cac34d46dd0be3bea3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga8bdd83f750f5744d43eca9d4bd6a5829">retype</a> (const <a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga8bdd83f750f5744d43eca9d4bd6a5829"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga7052ef9c261b2920c1d9776c709b1e58">retype</a> (const <a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga7052ef9c261b2920c1d9776c709b1e58"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaf36ee4d23dd52a64581e7c4c910c9f1a">retype</a> (const <a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaf36ee4d23dd52a64581e7c4c910c9f1a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga8f781343421e1001c500e2b312540996">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga8f781343421e1001c500e2b312540996"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga1be8e18a2d926fe05f379ee873509e13">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga1be8e18a2d926fe05f379ee873509e13"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga7c08332e213b24f3a1dac3baef565f2a">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga7c08332e213b24f3a1dac3baef565f2a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gabda38cd11844274e3e51bd2035dbf36d">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gabda38cd11844274e3e51bd2035dbf36d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga0c551ce2c6cd33213ca7556bb44f5f71">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga0c551ce2c6cd33213ca7556bb44f5f71"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga285e98505a83458e591ac8f81505d718">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga285e98505a83458e591ac8f81505d718"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga0042d4ef6a5536690566021736fa6213">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga0042d4ef6a5536690566021736fa6213"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga3e0d3de5fc57955a96d3db8dbea267ef">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga3e0d3de5fc57955a96d3db8dbea267ef"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gac159359d12e988a4042fee69cdffb260">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gac159359d12e988a4042fee69cdffb260"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga54f984d1ddfce7e7f5c7ac6e8800675e">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga54f984d1ddfce7e7f5c7ac6e8800675e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gad97ff1a4b529b070b1bfb2ed598f0e98">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gad97ff1a4b529b070b1bfb2ed598f0e98"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga261e3ef98bb1aa6c86dd4e3dc0195457">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga261e3ef98bb1aa6c86dd4e3dc0195457"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga16e56552d93a46cb664f1c267b4a41cb">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga16e56552d93a46cb664f1c267b4a41cb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga82c82e2a1b2ac6dbe4baeec025acdd7c">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga82c82e2a1b2ac6dbe4baeec025acdd7c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga6f8404a58be11fc49928b098592b3ff6">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga6f8404a58be11fc49928b098592b3ff6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga1dd02144060a987fb44157ae1e79aa78">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga1dd02144060a987fb44157ae1e79aa78"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga391a28defc597ed6434314b65c89d7b8">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga391a28defc597ed6434314b65c89d7b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga5201341f562754629a7cba4b1ac154e6">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga5201341f562754629a7cba4b1ac154e6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga3309f2e87e8a891e1df3d6b0431b5fc4">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga3309f2e87e8a891e1df3d6b0431b5fc4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga642deff61c5980807d1917646a3c69d2">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga642deff61c5980807d1917646a3c69d2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga362b9fc9259bea7531f4d31fd512fb7b">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga362b9fc9259bea7531f4d31fd512fb7b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga1d1d2a4923c49091a872c0473f90b932">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga1d1d2a4923c49091a872c0473f90b932"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga305a1136ea520aa403a15a53e28a08de">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga305a1136ea520aa403a15a53e28a08de"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaf825539eff18a01e234fc74a59c78026">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaf825539eff18a01e234fc74a59c78026"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaca710e4d681b9c3a3fec16e5c93cbbf2">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaca710e4d681b9c3a3fec16e5c93cbbf2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga8fa17b784993d6336d779e296201cf8f">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga8fa17b784993d6336d779e296201cf8f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gafb998719aad04fe4f5a856e11cf55e0e">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gafb998719aad04fe4f5a856e11cf55e0e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gabcd6bac846159593b21f30227d493684">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gabcd6bac846159593b21f30227d493684"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gadf4f9428ed1133a78722846f5c0132a9">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gadf4f9428ed1133a78722846f5c0132a9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga5d8a7da70b383ecef08a20855989b635">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga5d8a7da70b383ecef08a20855989b635"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga368120cf8bee8ec48c74c2c43df4d356">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga368120cf8bee8ec48c74c2c43df4d356"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga90823e5a559293b7fc4883c634059d02">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga90823e5a559293b7fc4883c634059d02"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga2e7b340189aaab7bc618b15397572a26">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga2e7b340189aaab7bc618b15397572a26"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gacf8109a58cf43637ad16cf0820bb0134">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gacf8109a58cf43637ad16cf0820bb0134"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga72caa009922c7b22978450c6514b99d1">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga72caa009922c7b22978450c6514b99d1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga727cc85e51e3bb4bfb759859af37a541">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga727cc85e51e3bb4bfb759859af37a541"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga4e04c4e9a0b68db775674103a0d4f0b4">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga4e04c4e9a0b68db775674103a0d4f0b4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaa3e551f631b23862dc0683cf81ed516e">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaa3e551f631b23862dc0683cf81ed516e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga2ba3cb34f35d03672b0d22c5e113a8b3">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga2ba3cb34f35d03672b0d22c5e113a8b3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga41785f8bca665c1d37644e03cc4996b6">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga41785f8bca665c1d37644e03cc4996b6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gacd0c8c77539d8b8005d02c8b337c2e01">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gacd0c8c77539d8b8005d02c8b337c2e01"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga2919261a6fddae2a22087d7750fa6a6a">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga2919261a6fddae2a22087d7750fa6a6a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaeba4fa26d1230185f1e48dcbc28b200e">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaeba4fa26d1230185f1e48dcbc28b200e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga750235d3681709542c2e582b4c637c42">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga750235d3681709542c2e582b4c637c42"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga98e8f225d52f338bc6edbb7287da8dc3">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga98e8f225d52f338bc6edbb7287da8dc3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaf85fd7ffaa77b335027ffb6d50fd84b9">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaf85fd7ffaa77b335027ffb6d50fd84b9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaacb3c94f389588e414d9c1aed1ed38de">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaacb3c94f389588e414d9c1aed1ed38de"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga81473a2f2432ead60c96a4af77fbe892">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga81473a2f2432ead60c96a4af77fbe892"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga4f536365709d563dad97f6daae927ab1">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga4f536365709d563dad97f6daae927ab1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaf3e306d9428c5638a70bdbd727af704d">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaf3e306d9428c5638a70bdbd727af704d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga27bd82fbe55fead4b199d296f4c6b1d9">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga27bd82fbe55fead4b199d296f4c6b1d9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaab0980106c1cf33f936f6e64df3c5e03">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaab0980106c1cf33f936f6e64df3c5e03"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga63b05a1b0442b8969f95fae079c98e86">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga63b05a1b0442b8969f95fae079c98e86"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga6c0f509a5dcc66444e28faa3c2aff6a7">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga6c0f509a5dcc66444e28faa3c2aff6a7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaec5e8fd715e7eb3e7a19aa53f2e53864">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaec5e8fd715e7eb3e7a19aa53f2e53864"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaffc5091a0592e9516708231a55549438">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaffc5091a0592e9516708231a55549438"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_setter , class T_getter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compose.html#ga3e7453863caa786e5e6a0401a8450958">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1compose1__functor.html">compose1_functor</a>&lt; T_setter, T_getter &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__compose.html#ga3e7453863caa786e5e6a0401a8450958"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_setter , class T_getter1 , class T_getter2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compose.html#ga234770a49ae510afbf6530047005294e">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1compose2__functor.html">compose2_functor</a>&lt; T_setter, T_getter1, T_getter2 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__compose.html#ga234770a49ae510afbf6530047005294e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_setter , class T_getter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1compose1__functor.html">compose1_functor</a>&lt; T_setter, <br class="typebreak"/>
T_getter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compose.html#ga57692495ec80dd855d4653adde4c8f49">compose</a> (const T_setter&amp; _A_setter, const T_getter&amp; _A_getter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1compose1__functor.html" title="Adaptor that combines two functors.">sigc::compose1_functor</a> which combines two functors. <a href="group__compose.html#ga57692495ec80dd855d4653adde4c8f49"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_setter , class T_getter1 , class T_getter2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1compose2__functor.html">compose2_functor</a>&lt; T_setter, <br class="typebreak"/>
T_getter1, T_getter2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compose.html#ga5ccef00a13aa5672806c46d4abe4ce55">compose</a> (const T_setter&amp; _A_setter, const T_getter1&amp; _A_getter1, const T_getter2&amp; _A_getter2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1compose2__functor.html" title="Adaptor that combines three functors.">sigc::compose2_functor</a> which combines three functors. <a href="group__compose.html#ga5ccef00a13aa5672806c46d4abe4ce55"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa223e54f7b85d4234b330a1c8502b6ba"></a><!-- doxytag: member="sigc::visit_each" ref="aa223e54f7b85d4234b330a1c8502b6ba" args="(const T_action &amp;_A_action, const exception_catch_functor&lt; T_functor, T_catcher, T_return &gt; &amp;_A_target)" -->
template &lt;class T_action , class T_functor , class T_catcher , class T_return &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const exception_catch_functor&lt; T_functor, T_catcher, T_return &gt; &amp;_A_target)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9aee9af00f94197bed616f6a5059c491"></a><!-- doxytag: member="sigc::exception_catch" ref="a9aee9af00f94197bed616f6a5059c491" args="(const T_functor &amp;_A_func, const T_catcher &amp;_A_catcher)" -->
template &lt;class T_functor , class T_catcher &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">exception_catch_functor<br class="typebreak"/>
&lt; T_functor, T_catcher &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exception_catch</b> (const T_functor &amp;_A_func, const T_catcher &amp;_A_catcher)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac14e861d541fd6172fd66bd96b79d3c1"></a><!-- doxytag: member="sigc::visit_each" ref="ac14e861d541fd6172fd66bd96b79d3c1" args="(const T_action &amp;_A_action, const internal::lambda_core&lt; T_functor, I_islambda &gt; &amp;_A_target)" -->
template &lt;class T_action , class T_functor , bool I_islambda&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const internal::lambda_core&lt; T_functor, I_islambda &gt; &amp;_A_target)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6df6801c9173642c618ac337112bb2b7"></a><!-- doxytag: member="sigc::visit_each" ref="a6df6801c9173642c618ac337112bb2b7" args="(const T_action &amp;_A_action, const lambda&lt; T_type &gt; &amp;_A_target)" -->
template &lt;class T_action , class T_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_type &gt;&amp; _A_target)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_type&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#aa354a134fa27b2dc8295af1c871b5885">var</a> (T_type&amp; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a reference into a <a class="el" href="structsigc_1_1lambda.html" title="Lambda type.">lambda</a> object. <a href="#aa354a134fa27b2dc8295af1c871b5885"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad0f037b8944e6c5828ccbffa28726525"></a><!-- doxytag: member="sigc::var" ref="ad0f037b8944e6c5828ccbffa28726525" args="(const T_type &amp;v)" -->
template &lt;class T_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; const T_type&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ad0f037b8944e6c5828ccbffa28726525">var</a> (const T_type&amp; v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a constant reference into a <a class="el" href="structsigc_1_1lambda.html" title="Lambda type.">lambda</a> object. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T_type&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a72c9f563f8d97738fa8d3d494e0ff0f5">unwrap_lambda_value</a> (T_type&amp; a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the object stored inside a <a class="el" href="structsigc_1_1lambda.html" title="Lambda type.">lambda</a> object. <a href="#a72c9f563f8d97738fa8d3d494e0ff0f5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d9b97698fd134e2ec1e103fbe893b07"></a><!-- doxytag: member="sigc::unwrap_lambda_value" ref="a6d9b97698fd134e2ec1e103fbe893b07" args="(const T_type &amp;a)" -->
template &lt;class T_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const T_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unwrap_lambda_value</b> (const T_type &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a55f65aefeb2254213ed4149610c58e16"></a><!-- doxytag: member="sigc::unwrap_lambda_value" ref="a55f65aefeb2254213ed4149610c58e16" args="(const lambda&lt; T_type &gt; &amp;a)" -->
template &lt;class T_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const T_type&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unwrap_lambda_value</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_type &gt;&amp; a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aeff5a0299fefc2899b6a920ec35539b1"></a><!-- doxytag: member="sigc::visit_each" ref="aeff5a0299fefc2899b6a920ec35539b1" args="(const T_action &amp;_A_action, const lambda_operator&lt;T_lambda_action, T_arg1, T_arg2 &gt; &amp;_A_target)" -->
template &lt;class T_action , class T_lambda_action , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const lambda_operator&lt;T_lambda_action, T_arg1, T_arg2 &gt; &amp;_A_target)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a63a15030d38a903406a7f0e3b4ef220a"></a><!-- doxytag: member="sigc::visit_each" ref="a63a15030d38a903406a7f0e3b4ef220a" args="(const T_action &amp;_A_action, const lambda_operator_unary&lt; T_lambda_action, T_arg &gt; &amp;_A_target)" -->
template &lt;class T_action , class T_lambda_action , class T_arg &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const lambda_operator_unary&lt; T_lambda_action, T_arg &gt; &amp;_A_target)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3413af839d2a7c15cbcd24e5d3098542"></a><!-- doxytag: member="sigc::visit_each" ref="a3413af839d2a7c15cbcd24e5d3098542" args="(const T_action &amp;_A_action, const lambda_operator_convert&lt; T_lambda_action, T_type, T_arg &gt; &amp;_A_target)" -->
template &lt;class T_action , class T_lambda_action , class T_type , class T_arg &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const lambda_operator_convert&lt; T_lambda_action, T_type, T_arg &gt; &amp;_A_target)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a29d226d0e89c123a6a99df7cf7049e98"></a><!-- doxytag: member="sigc::operator+" ref="a29d226d0e89c123a6a99df7cf7049e98" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; plus &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="acc0c03760fce65203d5f67f23a05aee7"></a><!-- doxytag: member="sigc::operator+" ref="acc0c03760fce65203d5f67f23a05aee7" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; plus &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a74d41ed6e82b12e9d2079776d1381a1b"></a><!-- doxytag: member="sigc::operator+" ref="a74d41ed6e82b12e9d2079776d1381a1b" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; plus &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a26c54de4f570705ef709f745a1ded9c7"></a><!-- doxytag: member="sigc::operator&#45;" ref="a26c54de4f570705ef709f745a1ded9c7" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; minus &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aebf7d41a285af52c58329c66183aca15"></a><!-- doxytag: member="sigc::operator&#45;" ref="aebf7d41a285af52c58329c66183aca15" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; minus &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a000e30854e2ad97c82db1c8e55ae9c58"></a><!-- doxytag: member="sigc::operator&#45;" ref="a000e30854e2ad97c82db1c8e55ae9c58" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; minus &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a523f6f89fe4d5d7d192ab1ed28e0093e"></a><!-- doxytag: member="sigc::operator*" ref="a523f6f89fe4d5d7d192ab1ed28e0093e" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; multiplies &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae3b395b68cc125b0a06f81719fe38d79"></a><!-- doxytag: member="sigc::operator*" ref="ae3b395b68cc125b0a06f81719fe38d79" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; multiplies &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1b911751ab6a9f1961406ca40e22dbef"></a><!-- doxytag: member="sigc::operator*" ref="a1b911751ab6a9f1961406ca40e22dbef" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; multiplies &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2cd49ce61ca95eef20291ceaaa14f7f3"></a><!-- doxytag: member="sigc::operator/" ref="a2cd49ce61ca95eef20291ceaaa14f7f3" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; divides &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a04d7fd3f8ecfe2ace16a5f03c318a56d"></a><!-- doxytag: member="sigc::operator/" ref="a04d7fd3f8ecfe2ace16a5f03c318a56d" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; divides &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a778da0346854b55c0605811e427f7ece"></a><!-- doxytag: member="sigc::operator/" ref="a778da0346854b55c0605811e427f7ece" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; divides &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a448f704e10cf7099d202544144257829"></a><!-- doxytag: member="sigc::operator%" ref="a448f704e10cf7099d202544144257829" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; modulus &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0df1bd3cac2a2bfbb43d250aec11b171"></a><!-- doxytag: member="sigc::operator%" ref="a0df1bd3cac2a2bfbb43d250aec11b171" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; modulus &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8900336dc8fbdcc1719095a98728aa07"></a><!-- doxytag: member="sigc::operator%" ref="a8900336dc8fbdcc1719095a98728aa07" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; modulus &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2be0aea0eb8880432737d42fa166a226"></a><!-- doxytag: member="sigc::operator&lt;&lt;" ref="a2be0aea0eb8880432737d42fa166a226" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; leftshift &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a43931fdef62a0517ba0924de2f82d0a9"></a><!-- doxytag: member="sigc::operator&lt;&lt;" ref="a43931fdef62a0517ba0924de2f82d0a9" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; leftshift &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a15266193ad2aad0a0b5c77b9d54f778e"></a><!-- doxytag: member="sigc::operator&lt;&lt;" ref="a15266193ad2aad0a0b5c77b9d54f778e" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; leftshift &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af82dddd5da2b904553cac0cbe28fbdef"></a><!-- doxytag: member="sigc::operator&gt;&gt;" ref="af82dddd5da2b904553cac0cbe28fbdef" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; rightshift &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5d32e408b09d4b18017401a618deca22"></a><!-- doxytag: member="sigc::operator&gt;&gt;" ref="a5d32e408b09d4b18017401a618deca22" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; rightshift &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a961c52af18d38be10448d6305875ec42"></a><!-- doxytag: member="sigc::operator&gt;&gt;" ref="a961c52af18d38be10448d6305875ec42" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; rightshift &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6fb888b7835fa083b03dee4ce8342dc3"></a><!-- doxytag: member="sigc::operator&amp;" ref="a6fb888b7835fa083b03dee4ce8342dc3" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; and_ &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5787fecd19ef8a83bf4e0452bfda5316"></a><!-- doxytag: member="sigc::operator&amp;" ref="a5787fecd19ef8a83bf4e0452bfda5316" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; and_ &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aecd89026594db3989ba4bbbc04bc20a7"></a><!-- doxytag: member="sigc::operator&amp;" ref="aecd89026594db3989ba4bbbc04bc20a7" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; and_ &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7d613863e01f8cf39a3f7a67be586b37"></a><!-- doxytag: member="sigc::operator|" ref="a7d613863e01f8cf39a3f7a67be586b37" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; or_ &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a79c58fce0596a170e3eb32aa589aa573"></a><!-- doxytag: member="sigc::operator|" ref="a79c58fce0596a170e3eb32aa589aa573" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; or_ &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2298b1d7394469e603ef17122d29e2c5"></a><!-- doxytag: member="sigc::operator|" ref="a2298b1d7394469e603ef17122d29e2c5" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; or_ &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9bd6e35894b866758aa37ec441e46c1b"></a><!-- doxytag: member="sigc::operator^" ref="a9bd6e35894b866758aa37ec441e46c1b" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; xor_ &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af5b039f488caaf8422ce7e04f8d22fd2"></a><!-- doxytag: member="sigc::operator^" ref="af5b039f488caaf8422ce7e04f8d22fd2" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; xor_ &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a455402cbd5b9af2923150b24f1b586ed"></a><!-- doxytag: member="sigc::operator^" ref="a455402cbd5b9af2923150b24f1b586ed" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; xor_ &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a844ae5a448ae2ceedd289dd09005314e"></a><!-- doxytag: member="sigc::operator&amp;&amp;" ref="a844ae5a448ae2ceedd289dd09005314e" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;logical&lt; and_ &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae670777fa2a815b93ce09f327b61894d"></a><!-- doxytag: member="sigc::operator&amp;&amp;" ref="ae670777fa2a815b93ce09f327b61894d" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;logical&lt; and_ &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3901e38688c83b70f22279db43338538"></a><!-- doxytag: member="sigc::operator&amp;&amp;" ref="a3901e38688c83b70f22279db43338538" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;logical&lt; and_ &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5c4eea4d6cfb47d019091f7b64177dcc"></a><!-- doxytag: member="sigc::operator||" ref="a5c4eea4d6cfb47d019091f7b64177dcc" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;logical&lt; or_ &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="abe7b14c8d37e24cc62259aba382f5b3e"></a><!-- doxytag: member="sigc::operator||" ref="abe7b14c8d37e24cc62259aba382f5b3e" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;logical&lt; or_ &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ab185848c59fea219a747cb1009f1c881"></a><!-- doxytag: member="sigc::operator||" ref="ab185848c59fea219a747cb1009f1c881" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;logical&lt; or_ &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a64587ad0e3a569be542d546b9b1d9829"></a><!-- doxytag: member="sigc::operator&lt;" ref="a64587ad0e3a569be542d546b9b1d9829" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; less &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa0f064417347c15e6c2eee46645f4b58"></a><!-- doxytag: member="sigc::operator&lt;" ref="aa0f064417347c15e6c2eee46645f4b58" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; less &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae84ae7410cde285a4062beec3f2581dd"></a><!-- doxytag: member="sigc::operator&lt;" ref="ae84ae7410cde285a4062beec3f2581dd" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; less &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a82df52344c1995f4b7f66efa2c6dd1e1"></a><!-- doxytag: member="sigc::operator&gt;" ref="a82df52344c1995f4b7f66efa2c6dd1e1" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; greater &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aaed6caf81d925870fbc306ecaf562a9a"></a><!-- doxytag: member="sigc::operator&gt;" ref="aaed6caf81d925870fbc306ecaf562a9a" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; greater &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a56f75748c8b6018401b8f82a93f29a58"></a><!-- doxytag: member="sigc::operator&gt;" ref="a56f75748c8b6018401b8f82a93f29a58" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; greater &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a276ae53620c9234c7964816aa94ba476"></a><!-- doxytag: member="sigc::operator&lt;=" ref="a276ae53620c9234c7964816aa94ba476" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; less_equal &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="affb5949de125154ba78a9fab53e5c88f"></a><!-- doxytag: member="sigc::operator&lt;=" ref="affb5949de125154ba78a9fab53e5c88f" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; less_equal &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4a9e25129fc0832aa465ce7ec679a1be"></a><!-- doxytag: member="sigc::operator&lt;=" ref="a4a9e25129fc0832aa465ce7ec679a1be" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; less_equal &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae1c71b2dfbafd2701d1ee7be0a5c603b"></a><!-- doxytag: member="sigc::operator&gt;=" ref="ae1c71b2dfbafd2701d1ee7be0a5c603b" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; greater_equal &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a109def8701355bae896321317c9fbda3"></a><!-- doxytag: member="sigc::operator&gt;=" ref="a109def8701355bae896321317c9fbda3" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; greater_equal &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8783dd0b543f6b51467ec1256a694174"></a><!-- doxytag: member="sigc::operator&gt;=" ref="a8783dd0b543f6b51467ec1256a694174" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; greater_equal &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3d4a437822ac13a0b06f8d629f162441"></a><!-- doxytag: member="sigc::operator==" ref="a3d4a437822ac13a0b06f8d629f162441" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; equal_to &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6a642d0f9179d581a95ac21ad10003b5"></a><!-- doxytag: member="sigc::operator==" ref="a6a642d0f9179d581a95ac21ad10003b5" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; equal_to &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a934ffbd686558b72a1ee12e4d9207a93"></a><!-- doxytag: member="sigc::operator==" ref="a934ffbd686558b72a1ee12e4d9207a93" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; equal_to &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2e406f67fa7336e1e6af7f2b6de89563"></a><!-- doxytag: member="sigc::operator!=" ref="a2e406f67fa7336e1e6af7f2b6de89563" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; not_equal_to &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a35550c6b98eab98d75f088abb1c06f6d"></a><!-- doxytag: member="sigc::operator!=" ref="a35550c6b98eab98d75f088abb1c06f6d" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; not_equal_to &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0fc828769dcf706797f1b39f88b770f9"></a><!-- doxytag: member="sigc::operator!=" ref="a0fc828769dcf706797f1b39f88b770f9" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; not_equal_to &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae4450395ac4750ab095b170da8dfc0a0"></a><!-- doxytag: member="sigc::operator+=" ref="ae4450395ac4750ab095b170da8dfc0a0" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; plus &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a334380d2c5ffd5febefb5aa0bfc6d162"></a><!-- doxytag: member="sigc::operator+=" ref="a334380d2c5ffd5febefb5aa0bfc6d162" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; plus &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4f0fa4bcad9e6a2f2d084ae4d0253acc"></a><!-- doxytag: member="sigc::operator+=" ref="a4f0fa4bcad9e6a2f2d084ae4d0253acc" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; plus &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a053d463f15272d949eddd17c1eb6057c"></a><!-- doxytag: member="sigc::operator&#45;=" ref="a053d463f15272d949eddd17c1eb6057c" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; minus &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a098d8644120cfbecfce6c2fdf3dcf4fe"></a><!-- doxytag: member="sigc::operator&#45;=" ref="a098d8644120cfbecfce6c2fdf3dcf4fe" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; minus &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3f5f33195e31cf10b663d60bee6624be"></a><!-- doxytag: member="sigc::operator&#45;=" ref="a3f5f33195e31cf10b663d60bee6624be" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; minus &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a18e3eb7c7b9251cf5ce1caaf2d1b8d00"></a><!-- doxytag: member="sigc::operator*=" ref="a18e3eb7c7b9251cf5ce1caaf2d1b8d00" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; multiplies &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a08b03bbd0b5e0b15855b8c97bf2ae2f1"></a><!-- doxytag: member="sigc::operator*=" ref="a08b03bbd0b5e0b15855b8c97bf2ae2f1" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; multiplies &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3df33e809b2f8476f709cdfb1d638b1a"></a><!-- doxytag: member="sigc::operator*=" ref="a3df33e809b2f8476f709cdfb1d638b1a" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; multiplies &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8749ada1d603fb667f3170e056c3d3fe"></a><!-- doxytag: member="sigc::operator/=" ref="a8749ada1d603fb667f3170e056c3d3fe" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; divides &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a190f94964b496b4389ff0695459c97f2"></a><!-- doxytag: member="sigc::operator/=" ref="a190f94964b496b4389ff0695459c97f2" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; divides &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a91c8284788f629046b289b1b8bb92fd2"></a><!-- doxytag: member="sigc::operator/=" ref="a91c8284788f629046b289b1b8bb92fd2" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; divides &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa22758b40768e4e1d5292711819e73f6"></a><!-- doxytag: member="sigc::operator%=" ref="aa22758b40768e4e1d5292711819e73f6" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; modulus &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a69bde4f0ffcf252e7b41e28c541943ba"></a><!-- doxytag: member="sigc::operator%=" ref="a69bde4f0ffcf252e7b41e28c541943ba" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; modulus &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac5379cb4329503d13767b738a076b157"></a><!-- doxytag: member="sigc::operator%=" ref="ac5379cb4329503d13767b738a076b157" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; modulus &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a717ad3389bb00a107750f9134d6170ef"></a><!-- doxytag: member="sigc::operator&lt;&lt;=" ref="a717ad3389bb00a107750f9134d6170ef" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; leftshift &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7d37efde4fa6742ef6090076ffde6d26"></a><!-- doxytag: member="sigc::operator&lt;&lt;=" ref="a7d37efde4fa6742ef6090076ffde6d26" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; leftshift &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa3c8ebf217044832c473285315d0c978"></a><!-- doxytag: member="sigc::operator&lt;&lt;=" ref="aa3c8ebf217044832c473285315d0c978" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; leftshift &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a002b4794715b5156dd45588364e52263"></a><!-- doxytag: member="sigc::operator&gt;&gt;=" ref="a002b4794715b5156dd45588364e52263" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; rightshift &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a898e016d767b6caa5dbf55b2df889524"></a><!-- doxytag: member="sigc::operator&gt;&gt;=" ref="a898e016d767b6caa5dbf55b2df889524" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; rightshift &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a77622d65d029ad3e13ed40e5c6506195"></a><!-- doxytag: member="sigc::operator&gt;&gt;=" ref="a77622d65d029ad3e13ed40e5c6506195" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; rightshift &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a88cbe01f27769c574176540d00add30e"></a><!-- doxytag: member="sigc::operator&amp;=" ref="a88cbe01f27769c574176540d00add30e" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; and_ &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7734d8f94efc34f1e014e99c177196bf"></a><!-- doxytag: member="sigc::operator&amp;=" ref="a7734d8f94efc34f1e014e99c177196bf" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; and_ &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3d5ff69dc22e356bb46a9b2126ad6ff1"></a><!-- doxytag: member="sigc::operator&amp;=" ref="a3d5ff69dc22e356bb46a9b2126ad6ff1" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; and_ &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a188bc271d74500df8b312869b7db9100"></a><!-- doxytag: member="sigc::operator|=" ref="a188bc271d74500df8b312869b7db9100" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; or_ &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a38281683e4f30ae38ebd9a77acadd68c"></a><!-- doxytag: member="sigc::operator|=" ref="a38281683e4f30ae38ebd9a77acadd68c" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; or_ &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5a32da57863bbe61bca7ef039e1e6c3a"></a><!-- doxytag: member="sigc::operator|=" ref="a5a32da57863bbe61bca7ef039e1e6c3a" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; or_ &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2108c7da0f2be4495e270b156f30cedd"></a><!-- doxytag: member="sigc::operator^=" ref="a2108c7da0f2be4495e270b156f30cedd" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; xor_ &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9fa6e2ff33616025e04285d6ad985b87"></a><!-- doxytag: member="sigc::operator^=" ref="a9fa6e2ff33616025e04285d6ad985b87" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; xor_ &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa1f413cd83d012ce882fcb2654bd9ca2"></a><!-- doxytag: member="sigc::operator^=" ref="aa1f413cd83d012ce882fcb2654bd9ca2" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; xor_ &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::type, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae9659bd5e4dafbdbef94794ab280fd44"></a><!-- doxytag: member="sigc::operator++" ref="ae9659bd5e4dafbdbef94794ab280fd44" args="(const lambda&lt; T_arg &gt; &amp;a)" -->
template &lt;class T_arg &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator_unary<br class="typebreak"/>
&lt; unary_arithmetic<br class="typebreak"/>
&lt; pre_increment &gt;, T_arg &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator++</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg &gt;&amp; a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a979840b7fcd28955b01524d2d352a731"></a><!-- doxytag: member="sigc::operator&#45;&#45;" ref="a979840b7fcd28955b01524d2d352a731" args="(const lambda&lt; T_arg &gt; &amp;a)" -->
template &lt;class T_arg &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator_unary<br class="typebreak"/>
&lt; unary_arithmetic<br class="typebreak"/>
&lt; pre_decrement &gt;, T_arg &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator--</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg &gt;&amp; a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa1e0215bf7c7cec50a46b4fbc5e09f88"></a><!-- doxytag: member="sigc::operator&#45;" ref="aa1e0215bf7c7cec50a46b4fbc5e09f88" args="(const lambda&lt; T_arg &gt; &amp;a)" -->
template &lt;class T_arg &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator_unary<br class="typebreak"/>
&lt; unary_arithmetic&lt; negate &gt;<br class="typebreak"/>
, T_arg &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg &gt;&amp; a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="adb7ab85e9d37fd0d23e68c39d4c9f7ae"></a><!-- doxytag: member="sigc::operator~" ref="adb7ab85e9d37fd0d23e68c39d4c9f7ae" args="(const lambda&lt; T_arg &gt; &amp;a)" -->
template &lt;class T_arg &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator_unary<br class="typebreak"/>
&lt; unary_bitwise&lt; not_ &gt;, T_arg &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator~</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg &gt;&amp; a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f087b34043a9ddd59fd58da582e4349"></a><!-- doxytag: member="sigc::operator!" ref="a1f087b34043a9ddd59fd58da582e4349" args="(const lambda&lt; T_arg &gt; &amp;a)" -->
template &lt;class T_arg &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator_unary<br class="typebreak"/>
&lt; unary_logical&lt; not_ &gt;, T_arg &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg &gt;&amp; a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3126b28903e6cfaa462f1518e13f4fb6"></a><!-- doxytag: member="sigc::operator&amp;" ref="a3126b28903e6cfaa462f1518e13f4fb6" args="(const lambda&lt; T_arg &gt; &amp;a)" -->
template &lt;class T_arg &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator_unary<br class="typebreak"/>
&lt; unary_other&lt; address &gt;<br class="typebreak"/>
, T_arg &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg &gt;&amp; a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7f9eb0f44a86fa8a4145d4872465f2e2"></a><!-- doxytag: member="sigc::operator*" ref="a7f9eb0f44a86fa8a4145d4872465f2e2" args="(const lambda&lt; T_arg &gt; &amp;a)" -->
template &lt;class T_arg &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator_unary<br class="typebreak"/>
&lt; unary_other&lt; dereference &gt;<br class="typebreak"/>
, T_arg &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg &gt;&amp; a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0ba07befc70db9c92da9a0ba298b7c4e"></a><!-- doxytag: member="sigc::reinterpret_cast_" ref="a0ba07befc70db9c92da9a0ba298b7c4e" args="(const T_arg &amp;a)" -->
template &lt;class T_type , class T_arg &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a><br class="typebreak"/>
&lt; lambda_operator_convert<br class="typebreak"/>
&lt; cast_&lt; reinterpret_ &gt;<br class="typebreak"/>
, T_type, typename <br class="typebreak"/>
<a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a>&lt; T_arg &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpret_cast_</b> (const T_arg &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a89e8b6d6a025937d9376edf132e369e9"></a><!-- doxytag: member="sigc::static_cast_" ref="a89e8b6d6a025937d9376edf132e369e9" args="(const T_arg &amp;a)" -->
template &lt;class T_type , class T_arg &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a><br class="typebreak"/>
&lt; lambda_operator_convert<br class="typebreak"/>
&lt; cast_&lt; static_ &gt;, T_type, <br class="typebreak"/>
typename <a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a><br class="typebreak"/>
&lt; T_arg &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>static_cast_</b> (const T_arg &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7eb410f49742a727c3292269b99771a2"></a><!-- doxytag: member="sigc::dynamic_cast_" ref="a7eb410f49742a727c3292269b99771a2" args="(const T_arg &amp;a)" -->
template &lt;class T_type , class T_arg &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a><br class="typebreak"/>
&lt; lambda_operator_convert<br class="typebreak"/>
&lt; cast_&lt; dynamic_ &gt;, T_type, <br class="typebreak"/>
typename <a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a><br class="typebreak"/>
&lt; T_arg &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_cast_</b> (const T_arg &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af281160792e31db1dac80bc28a932ce9"></a><!-- doxytag: member="sigc::visit_each" ref="af281160792e31db1dac80bc28a932ce9" args="(const T_action &amp;_A_action, const lambda_group1&lt; T_functor, T_type1 &gt; &amp;_A_target)" -->
template &lt;class T_action , class T_functor , class T_type1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const lambda_group1&lt; T_functor, T_type1 &gt; &amp;_A_target)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c1afe7cb631539be654133b0c1b35fc"></a><!-- doxytag: member="sigc::visit_each" ref="a3c1afe7cb631539be654133b0c1b35fc" args="(const T_action &amp;_A_action, const lambda_group2&lt; T_functor, T_type1, T_type2 &gt; &amp;_A_target)" -->
template &lt;class T_action , class T_functor , class T_type1 , class T_type2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const lambda_group2&lt; T_functor, T_type1, T_type2 &gt; &amp;_A_target)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a93983affe370fea0a52fe7f8f47ff7ba"></a><!-- doxytag: member="sigc::visit_each" ref="a93983affe370fea0a52fe7f8f47ff7ba" args="(const T_action &amp;_A_action, const lambda_group3&lt; T_functor, T_type1, T_type2, T_type3 &gt; &amp;_A_target)" -->
template &lt;class T_action , class T_functor , class T_type1 , class T_type2 , class T_type3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const lambda_group3&lt; T_functor, T_type1, T_type2, T_type3 &gt; &amp;_A_target)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad36281e6ca158599b36980a801f41aac"></a><!-- doxytag: member="sigc::group" ref="ad36281e6ca158599b36980a801f41aac" args="(const T_functor &amp;_A_func, T_type1 _A_1)" -->
template &lt;class T_functor , class T_type1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_group1<br class="typebreak"/>
&lt; T_functor, typename <br class="typebreak"/>
unwrap_reference&lt; T_type1 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>group</b> (const T_functor &amp;_A_func, T_type1 _A_1)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6a332480331574db008e225d6f7ac21a"></a><!-- doxytag: member="sigc::group" ref="a6a332480331574db008e225d6f7ac21a" args="(const T_functor &amp;_A_func, T_type1 _A_1, T_type2 _A_2)" -->
template &lt;class T_functor , class T_type1 , class T_type2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_group2<br class="typebreak"/>
&lt; T_functor, typename <br class="typebreak"/>
unwrap_reference&lt; T_type1 &gt;<br class="typebreak"/>
::type, typename <br class="typebreak"/>
unwrap_reference&lt; T_type2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>group</b> (const T_functor &amp;_A_func, T_type1 _A_1, T_type2 _A_2)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae9697b66a5fdb9b356d4b2eb88ad0b2c"></a><!-- doxytag: member="sigc::group" ref="ae9697b66a5fdb9b356d4b2eb88ad0b2c" args="(const T_functor &amp;_A_func, T_type1 _A_1, T_type2 _A_2, T_type3 _A_3)" -->
template &lt;class T_functor , class T_type1 , class T_type2 , class T_type3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_group3<br class="typebreak"/>
&lt; T_functor, typename <br class="typebreak"/>
unwrap_reference&lt; T_type1 &gt;<br class="typebreak"/>
::type, typename <br class="typebreak"/>
unwrap_reference&lt; T_type2 &gt;<br class="typebreak"/>
::type, typename <br class="typebreak"/>
unwrap_reference&lt; T_type3 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>group</b> (const T_functor &amp;_A_func, T_type1 _A_1, T_type2 _A_2, T_type3 _A_3)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The libsigc++ namespace. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaf28d43958b26c67e314f726540463c44"></a><!-- doxytag: member="sigc::hide" ref="gaf28d43958b26c67e314f726540463c44" args="(const T_functor &amp;_A_func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hide_functor&lt;-1, T_functor&gt; sigc::hide </td>
          <td>(</td>
          <td class="paramtype">const T_functor &amp;&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an adaptor of type sigc::hide_functor which adds a dummy parameter to the passed functor. </p>
<p>This overload adds a dummy parameter at the back of the functor's parameter list.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Functor that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Adaptor that executes <em>_A_func</em> ignoring the value of the last parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="a70808607392abfe36e726a7d7a455b54"></a><!-- doxytag: member="sigc::ref" ref="a70808607392abfe36e726a7d7a455b54" args="(const T_type &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a>&lt;T_type&gt; sigc::ref </td>
          <td>(</td>
          <td class="paramtype">const T_type &amp;&#160;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a const reference wrapper. </p>
<p>Passing an object throught <a class="el" href="namespacesigc.html#ad6e63f1697c807728f518f21f69e1931" title="Creates a reference wrapper.">sigc::ref()</a> makes libsigc++ adaptors like, e.g., <a class="el" href="group__bind.html#ga2148290d2cf9c1961ec157a085badd5a" title="Creates an adaptor of type sigc::bind_functor which binds the passed argument to...">sigc::bind</a> store references to the object instead of copies. If the object type inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a> this will ensure automatic invalidation of the adaptors when the object is deleted or overwritten.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&#160;</td><td>Reference to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference wrapper. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6e63f1697c807728f518f21f69e1931"></a><!-- doxytag: member="sigc::ref" ref="ad6e63f1697c807728f518f21f69e1931" args="(T_type &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a>&lt;T_type&gt; sigc::ref </td>
          <td>(</td>
          <td class="paramtype">T_type &amp;&#160;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a reference wrapper. </p>
<p>Passing an object throught <a class="el" href="namespacesigc.html#ad6e63f1697c807728f518f21f69e1931" title="Creates a reference wrapper.">sigc::ref()</a> makes libsigc++ adaptors like, e.g., <a class="el" href="group__bind.html#ga2148290d2cf9c1961ec157a085badd5a" title="Creates an adaptor of type sigc::bind_functor which binds the passed argument to...">sigc::bind</a> store references to the object instead of copies. If the object type inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a> this will ensure automatic invalidation of the adaptors when the object is deleted or overwritten.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&#160;</td><td>Reference to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference wrapper. </dd></dl>

</div>
</div>
<a class="anchor" id="a72c9f563f8d97738fa8d3d494e0ff0f5"></a><!-- doxytag: member="sigc::unwrap_lambda_value" ref="a72c9f563f8d97738fa8d3d494e0ff0f5" args="(T_type &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T_type&amp; sigc::unwrap_lambda_value </td>
          <td>(</td>
          <td class="paramtype">T_type &amp;&#160;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the object stored inside a <a class="el" href="structsigc_1_1lambda.html" title="Lambda type.">lambda</a> object. </p>
<p>Returns the object passed as argument if it is not of type <a class="el" href="structsigc_1_1lambda.html" title="Lambda type.">lambda</a>. </p>

</div>
</div>
<a class="anchor" id="aa354a134fa27b2dc8295af1c871b5885"></a><!-- doxytag: member="sigc::var" ref="aa354a134fa27b2dc8295af1c871b5885" args="(T_type &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_type&amp;&gt; sigc::var </td>
          <td>(</td>
          <td class="paramtype">T_type &amp;&#160;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a reference into a <a class="el" href="structsigc_1_1lambda.html" title="Lambda type.">lambda</a> object. </p>
<p><a class="el" href="namespacesigc.html#aa354a134fa27b2dc8295af1c871b5885" title="Converts a reference into a lambda object.">sigc::var</a> creates a 0-ary functor, returning the value of a referenced variable.</p>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv)
   {
     <span class="keywordtype">int</span> data;
     <a class="code" href="classsigc_1_1signal.html" title="Convenience wrapper for the numbered sigc::signal# templates.">sigc::signal&lt;int&gt;</a> readValue;

     readValue.<a class="code" href="classsigc_1_1signal7.html#adc55ac9b0f935fd87a67904022e03cb2" title="Add a slot to the list of slots.">connect</a>(<a class="code" href="namespacesigc.html#aa354a134fa27b2dc8295af1c871b5885" title="Converts a reference into a lambda object.">sigc::var</a>(data));

     data = 3;
     <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#aaf93fdf0812752e0e02c501dea1b38f0">std::cout</a> &lt;&lt; readValue() &lt;&lt; <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#a4a01795921d3387d04f02890447638d4">std::endl</a>; <span class="comment">//Prints 3.</span>

    data = 5;
    <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01127.html#aaf93fdf0812752e0e02c501dea1b38f0">std::cout</a> &lt;&lt; readValue() &lt;&lt; std::endl; <span class="comment">//Prints 5.</span>
   }
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="a0729e10eaf72affb56a48c20f7197009"></a><!-- doxytag: member="sigc::visit_each" ref="a0729e10eaf72affb56a48c20f7197009" args="(const T_action &amp;_A_action, const const_volatile_limit_reference&lt; T_type, I_derives_trackable &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_type , bool I_derives_trackable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_volatile_limit_reference&lt; T_type, I_derives_trackable &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1const__volatile__limit__reference.html" title="A const_volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;)...">const_volatile_limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the const_volatile_limit_reference's visit() method. </p>
<ul>
<li><em>T_action</em> The type of functor to invoke.</li>
<li><em>T_type</em> The type of the reference. <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_action</em>&#160;</td><td>The functor to invoke. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_argument</em>&#160;</td><td>The visited instance. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a6d8d4ebf03d12349254c840b6abeab1b"></a><!-- doxytag: member="sigc::visit_each" ref="a6d8d4ebf03d12349254c840b6abeab1b" args="(const T_action &amp;_A_action, const volatile_limit_reference&lt; T_type, I_derives_trackable &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_type , bool I_derives_trackable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile_limit_reference&lt; T_type, I_derives_trackable &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1volatile__limit__reference.html" title="A volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make...">volatile_limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the volatile_limit_reference's visit() method. </p>
<ul>
<li><em>T_action</em> The type of functor to invoke.</li>
<li><em>T_type</em> The type of the reference. <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_action</em>&#160;</td><td>The functor to invoke. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_argument</em>&#160;</td><td>The visited instance. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a3d6923539508a182c7c0f2cd14f7da76"></a><!-- doxytag: member="sigc::visit_each" ref="a3d6923539508a182c7c0f2cd14f7da76" args="(const T_action &amp;_A_action, const const_limit_reference&lt; T_type, I_derives_trackable &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_type , bool I_derives_trackable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_limit_reference&lt; T_type, I_derives_trackable &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1const__limit__reference.html" title="A const_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make...">const_limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the const_limit_reference's visit() method. </p>
<ul>
<li><em>T_action</em> The type of functor to invoke.</li>
<li><em>T_type</em> The type of the reference. <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_action</em>&#160;</td><td>The functor to invoke. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_argument</em>&#160;</td><td>The visited instance. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a45fbeeeed09915ba6eac52d8c0e6f601"></a><!-- doxytag: member="sigc::visit_each" ref="a45fbeeeed09915ba6eac52d8c0e6f601" args="(const T_action &amp;_A_action, const limit_reference&lt; T_type, I_derives_trackable &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_type , bool I_derives_trackable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const limit_reference&lt; T_type, I_derives_trackable &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1limit__reference.html" title="A limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure...">limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the limit_reference's visit() method. </p>
<ul>
<li><em>T_action</em> The type of functor to invoke.</li>
<li><em>T_type</em> The type of the reference. <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_action</em>&#160;</td><td>The functor to invoke. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_argument</em>&#160;</td><td>The visited instance. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a78af6ff8fb24c17f5e72fd36d0be7975"></a><!-- doxytag: member="sigc::visit_each" ref="a78af6ff8fb24c17f5e72fd36d0be7975" args="(const T_action &amp;_A_action, const bound_argument&lt; T_type &gt; &amp;_A_argument)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_argument&lt; T_type &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_argument</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1bound__argument.html" title="A bound_argument&lt;Foo&gt; object stores a bound (for instance, with sigc::bind()...">bound_argument</a> class. </p>
<p>Call <a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the bound_argument's visit() method. <em>T_action</em> The type of functor to invoke. <em>T_type</em> The type of <a class="el" href="classsigc_1_1bound__argument.html" title="A bound_argument&lt;Foo&gt; object stores a bound (for instance, with sigc::bind()...">bound_argument</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_action</em>&#160;</td><td>The functor to invoke. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_argument</em>&#160;</td><td>The visited instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Jun 4 16:11:36 2010 for libsigc++ by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
