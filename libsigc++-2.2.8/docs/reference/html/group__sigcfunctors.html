<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libsigc++: Functors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Functors</h1>
<p>Functors are copyable types that define operator()(). <a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__base.html">sigc::functor_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A hint to the compiler. <a href="structsigc_1_1functor__base.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slot.html">Slots</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Slots are type-safe representations of callback methods and functions. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html">ptr_fun()</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p><a class="el" href="group__ptr__fun.html#gada8b678665c14dc85eb32d25b7299465" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member...">ptr_fun()</a> is used to convert a pointer to a function to a functor. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mem__fun.html">mem_fun()</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p><a class="el" href="group__mem__fun.html#ga7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">mem_fun()</a> is used to convert a pointer to a method to a functor. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#ga93b6ee8815d90adccfdceed72bcda577">SIGC_FUNCTORS_HAVE_RESULT_TYPE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If you want to mix functors from a different library with libsigc++ and these functors define <code>result_type</code> simply use this macro inside namespace <a class="el" href="namespacesigc.html" title="The libsigc++ namespace.">sigc</a> like so:. <a href="#ga93b6ee8815d90adccfdceed72bcda577"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#ga7a6f5575dc0b0ea896889c782721f6be">SIGC_FUNCTOR_TRAIT</a>(T_functor, T_return)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If you want to mix functors from a different library with libsigc++ and these functors don't define <code>result_type</code> use this macro inside namespace <a class="el" href="namespacesigc.html" title="The libsigc++ namespace.">sigc</a> to expose the return type of the functors like so:. <a href="#ga7a6f5575dc0b0ea896889c782721f6be"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541">sigc::visit_each</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor. <a href="#gadab29aed05524743da16319da4430541"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5c455eda401dee43de931c24ad45d445"></a><!-- doxytag: member="sigcfunctors::visit_each_type" ref="ga5c455eda401dee43de931c24ad45d445" args="(const T_action &amp;_A_action, const T_functor &amp;_A_functor)" -->
template &lt;class T_type , class T_action , class T_functor &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#ga5c455eda401dee43de931c24ad45d445">sigc::visit_each_type</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor limited to a restricted type. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Functors are copyable types that define operator()(). </p>
<p>Types that define operator()() overloads with different return types are referred to as multi-type functors. Multi-type functors are only partly supported in libsigc++.</p>
<p>Closures are functors that store all information needed to invoke a callback from operator()().</p>
<p>Adaptors are functors that alter the signature of a functor's operator()().</p>
<p>libsigc++ defines numerous functors, closures and adaptors. Since libsigc++ is a callback libaray, most functors are also closures. The documentation doesn't distinguish between functors and closures.</p>
<p>The basic functor types libsigc++ provides are created with <a class="el" href="group__ptr__fun.html#gada8b678665c14dc85eb32d25b7299465" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member...">ptr_fun()</a> and <a class="el" href="group__mem__fun.html#ga7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">mem_fun()</a> and can be converted into slots implicitly. The set of adaptors that ships with libsigc++ is documented in the equally named module. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga7a6f5575dc0b0ea896889c782721f6be"></a><!-- doxytag: member="functor_trait.h::SIGC_FUNCTOR_TRAIT" ref="ga7a6f5575dc0b0ea896889c782721f6be" args="(T_functor, T_return)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGC_FUNCTOR_TRAIT</td>
          <td>(</td>
          <td class="paramtype">T_functor, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return&#160;</td>
          <td class="paramname"></td>
          <td>&#160;)&#160;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If you want to mix functors from a different library with libsigc++ and these functors don't define <code>result_type</code> use this macro inside namespace <a class="el" href="namespacesigc.html" title="The libsigc++ namespace.">sigc</a> to expose the return type of the functors like so:. </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">namespace </span>sigc {
   <a class="code" href="group__sigcfunctors.html#ga7a6f5575dc0b0ea896889c782721f6be" title="If you want to mix functors from a different library with libsigc++ and these functors...">SIGC_FUNCTOR_TRAIT</a>(first_functor_type, return_type_of_first_functor_type)
   <a class="code" href="group__sigcfunctors.html#ga7a6f5575dc0b0ea896889c782721f6be" title="If you want to mix functors from a different library with libsigc++ and these functors...">SIGC_FUNCTOR_TRAIT</a>(second_functor_type, return_type_of_second_functor_type)
   ...
 }
</pre></div> </div>
</div>
<a class="anchor" id="ga93b6ee8815d90adccfdceed72bcda577"></a><!-- doxytag: member="functor_trait.h::SIGC_FUNCTORS_HAVE_RESULT_TYPE" ref="ga93b6ee8815d90adccfdceed72bcda577" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGC_FUNCTORS_HAVE_RESULT_TYPE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If you want to mix functors from a different library with libsigc++ and these functors define <code>result_type</code> simply use this macro inside namespace <a class="el" href="namespacesigc.html" title="The libsigc++ namespace.">sigc</a> like so:. </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">namespace </span>sigc { <a class="code" href="group__sigcfunctors.html#ga93b6ee8815d90adccfdceed72bcda577" title="If you want to mix functors from a different library with libsigc++ and these functors...">SIGC_FUNCTORS_HAVE_RESULT_TYPE</a> }
</pre></div> </div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gadab29aed05524743da16319da4430541"></a><!-- doxytag: member="sigc::visit_each" ref="gadab29aed05524743da16319da4430541" args="(const T_action &amp;_A_action, const T_functor &amp;_A_functor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_functor &amp;&#160;</td>
          <td class="paramname"> <em>_A_functor</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function performs a functor on each of the targets of a functor. </p>
<p>All unknown types just call <em>_A_action</em> on them. Add overloads that specialize the <em>T_functor</em> argument for your own functor types, so that subobjects get visited. This is needed to enable auto-disconnection support for your functor types.</p>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>some_functor
   {
     <span class="keywordtype">void</span> operator()() {}
     some_possibly_sigc_trackable_derived_type some_data_member;
     some_other_functor_type some_other_functor;
   }

   <span class="keyword">namespace </span>sigc
   {
     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T_action&gt;
     <span class="keywordtype">void</span> <a class="code" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each</a>(<span class="keyword">const</span> T_action&amp; _A_action,
                     <span class="keyword">const</span> some_functor&amp; _A_target)
     {
       <a class="code" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each</a>(_A_action, _A_target.some_data_member);
       <a class="code" href="group__sigcfunctors.html#gadab29aed05524743da16319da4430541" title="This function performs a functor on each of the targets of a functor.">visit_each</a>(_A_action, _A_target.some_other_functor);
     }
   }
</pre></div> </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Jun 4 16:11:33 2010 for libsigc++ by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
