<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libsigc++: mem_fun()</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>mem_fun()<br/>
<small>
[<a class="el" href="group__sigcfunctors.html">Functors</a>]</small>
</h1>
<p><a class="el" href="group__mem__fun.html#ga7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">mem_fun()</a> is used to convert a pointer to a method to a functor. <a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor0.html">sigc::mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">mem_functor0</a> wraps methods with 0 argument(s). <a href="classsigc_1_1mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor1.html">sigc::mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">mem_functor1</a> wraps methods with 1 argument(s). <a href="classsigc_1_1mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor2.html">sigc::mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">mem_functor2</a> wraps methods with 2 argument(s). <a href="classsigc_1_1mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor3.html">sigc::mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">mem_functor3</a> wraps methods with 3 argument(s). <a href="classsigc_1_1mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor4.html">sigc::mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">mem_functor4</a> wraps methods with 4 argument(s). <a href="classsigc_1_1mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor5.html">sigc::mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">mem_functor5</a> wraps methods with 5 argument(s). <a href="classsigc_1_1mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor6.html">sigc::mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">mem_functor6</a> wraps methods with 6 argument(s). <a href="classsigc_1_1mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor7.html">sigc::mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">mem_functor7</a> wraps methods with 7 argument(s). <a href="classsigc_1_1mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor0.html">sigc::const_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor0.html" title="const_mem_functor0 wraps const methods with 0 argument(s).">const_mem_functor0</a> wraps const methods with 0 argument(s). <a href="classsigc_1_1const__mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor1.html">sigc::const_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor1.html" title="const_mem_functor1 wraps const methods with 1 argument(s).">const_mem_functor1</a> wraps const methods with 1 argument(s). <a href="classsigc_1_1const__mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor2.html">sigc::const_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor2.html" title="const_mem_functor2 wraps const methods with 2 argument(s).">const_mem_functor2</a> wraps const methods with 2 argument(s). <a href="classsigc_1_1const__mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor3.html">sigc::const_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor3.html" title="const_mem_functor3 wraps const methods with 3 argument(s).">const_mem_functor3</a> wraps const methods with 3 argument(s). <a href="classsigc_1_1const__mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor4.html">sigc::const_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor4.html" title="const_mem_functor4 wraps const methods with 4 argument(s).">const_mem_functor4</a> wraps const methods with 4 argument(s). <a href="classsigc_1_1const__mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor5.html">sigc::const_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor5.html" title="const_mem_functor5 wraps const methods with 5 argument(s).">const_mem_functor5</a> wraps const methods with 5 argument(s). <a href="classsigc_1_1const__mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor6.html">sigc::const_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor6.html" title="const_mem_functor6 wraps const methods with 6 argument(s).">const_mem_functor6</a> wraps const methods with 6 argument(s). <a href="classsigc_1_1const__mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor7.html">sigc::const_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor7.html" title="const_mem_functor7 wraps const methods with 7 argument(s).">const_mem_functor7</a> wraps const methods with 7 argument(s). <a href="classsigc_1_1const__mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">sigc::volatile_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor0.html" title="volatile_mem_functor0 wraps volatile methods with 0 argument(s).">volatile_mem_functor0</a> wraps volatile methods with 0 argument(s). <a href="classsigc_1_1volatile__mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">sigc::volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor1.html" title="volatile_mem_functor1 wraps volatile methods with 1 argument(s).">volatile_mem_functor1</a> wraps volatile methods with 1 argument(s). <a href="classsigc_1_1volatile__mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">sigc::volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor2.html" title="volatile_mem_functor2 wraps volatile methods with 2 argument(s).">volatile_mem_functor2</a> wraps volatile methods with 2 argument(s). <a href="classsigc_1_1volatile__mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">sigc::volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor3.html" title="volatile_mem_functor3 wraps volatile methods with 3 argument(s).">volatile_mem_functor3</a> wraps volatile methods with 3 argument(s). <a href="classsigc_1_1volatile__mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">sigc::volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor4.html" title="volatile_mem_functor4 wraps volatile methods with 4 argument(s).">volatile_mem_functor4</a> wraps volatile methods with 4 argument(s). <a href="classsigc_1_1volatile__mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">sigc::volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor5.html" title="volatile_mem_functor5 wraps volatile methods with 5 argument(s).">volatile_mem_functor5</a> wraps volatile methods with 5 argument(s). <a href="classsigc_1_1volatile__mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">sigc::volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor6.html" title="volatile_mem_functor6 wraps volatile methods with 6 argument(s).">volatile_mem_functor6</a> wraps volatile methods with 6 argument(s). <a href="classsigc_1_1volatile__mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">sigc::volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor7.html" title="volatile_mem_functor7 wraps volatile methods with 7 argument(s).">volatile_mem_functor7</a> wraps volatile methods with 7 argument(s). <a href="classsigc_1_1volatile__mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html" title="const_volatile_mem_functor0 wraps const volatile methods with 0 argument(s).">const_volatile_mem_functor0</a> wraps const volatile methods with 0 argument(s). <a href="classsigc_1_1const__volatile__mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html" title="const_volatile_mem_functor1 wraps const volatile methods with 1 argument(s).">const_volatile_mem_functor1</a> wraps const volatile methods with 1 argument(s). <a href="classsigc_1_1const__volatile__mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html" title="const_volatile_mem_functor2 wraps const volatile methods with 2 argument(s).">const_volatile_mem_functor2</a> wraps const volatile methods with 2 argument(s). <a href="classsigc_1_1const__volatile__mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html" title="const_volatile_mem_functor3 wraps const volatile methods with 3 argument(s).">const_volatile_mem_functor3</a> wraps const volatile methods with 3 argument(s). <a href="classsigc_1_1const__volatile__mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html" title="const_volatile_mem_functor4 wraps const volatile methods with 4 argument(s).">const_volatile_mem_functor4</a> wraps const volatile methods with 4 argument(s). <a href="classsigc_1_1const__volatile__mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html" title="const_volatile_mem_functor5 wraps const volatile methods with 5 argument(s).">const_volatile_mem_functor5</a> wraps const volatile methods with 5 argument(s). <a href="classsigc_1_1const__volatile__mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html" title="const_volatile_mem_functor6 wraps const volatile methods with 6 argument(s).">const_volatile_mem_functor6</a> wraps const volatile methods with 6 argument(s). <a href="classsigc_1_1const__volatile__mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html" title="const_volatile_mem_functor7 wraps const volatile methods with 7 argument(s).">const_volatile_mem_functor7</a> wraps const volatile methods with 7 argument(s). <a href="classsigc_1_1const__volatile__mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor0.html">sigc::bound_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance...">bound_mem_functor0</a> encapsulates a method with 0 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor1.html">sigc::bound_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance...">bound_mem_functor1</a> encapsulates a method with 1 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor2.html">sigc::bound_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance...">bound_mem_functor2</a> encapsulates a method with 2 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor3.html">sigc::bound_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance...">bound_mem_functor3</a> encapsulates a method with 3 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor4.html">sigc::bound_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance...">bound_mem_functor4</a> encapsulates a method with 4 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor5.html">sigc::bound_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance...">bound_mem_functor5</a> encapsulates a method with 5 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor6.html">sigc::bound_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance...">bound_mem_functor6</a> encapsulates a method with 6 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor7.html">sigc::bound_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance...">bound_mem_functor7</a> encapsulates a method with 7 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object...">bound_const_mem_functor0</a> encapsulates a const method with 0 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object...">bound_const_mem_functor1</a> encapsulates a const method with 1 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object...">bound_const_mem_functor2</a> encapsulates a const method with 2 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object...">bound_const_mem_functor3</a> encapsulates a const method with 3 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object...">bound_const_mem_functor4</a> encapsulates a const method with 4 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object...">bound_const_mem_functor5</a> encapsulates a const method with 5 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object...">bound_const_mem_functor6</a> encapsulates a const method with 6 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object...">bound_const_mem_functor7</a> encapsulates a const method with 7 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">sigc::bound_volatile_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an...">bound_volatile_mem_functor0</a> encapsulates a volatile method with 0 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">sigc::bound_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an...">bound_volatile_mem_functor1</a> encapsulates a volatile method with 1 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">sigc::bound_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an...">bound_volatile_mem_functor2</a> encapsulates a volatile method with 2 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">sigc::bound_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an...">bound_volatile_mem_functor3</a> encapsulates a volatile method with 3 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">sigc::bound_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an...">bound_volatile_mem_functor4</a> encapsulates a volatile method with 4 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">sigc::bound_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an...">bound_volatile_mem_functor5</a> encapsulates a volatile method with 5 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">sigc::bound_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an...">bound_volatile_mem_functor6</a> encapsulates a volatile method with 6 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">sigc::bound_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an...">bound_volatile_mem_functor7</a> encapsulates a volatile method with 7 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments...">bound_const_volatile_mem_functor0</a> encapsulates a const volatile method with 0 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor0.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments...">bound_const_volatile_mem_functor1</a> encapsulates a const volatile method with 1 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments...">bound_const_volatile_mem_functor2</a> encapsulates a const volatile method with 2 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments...">bound_const_volatile_mem_functor3</a> encapsulates a const volatile method with 3 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments...">bound_const_volatile_mem_functor4</a> encapsulates a const volatile method with 4 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments...">bound_const_volatile_mem_functor5</a> encapsulates a const volatile method with 5 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments...">bound_const_volatile_mem_functor6</a> encapsulates a const volatile method with 6 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor6.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments...">bound_const_volatile_mem_functor7</a> encapsulates a const volatile method with 7 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor7.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga8a0e4bdca79dde7347318bff4d6e1eda">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor0&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga8a0e4bdca79dde7347318bff4d6e1eda"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaff3264460325cf2a34cc0502fec7b8b7">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gaff3264460325cf2a34cc0502fec7b8b7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga497c57551529e8721861cedc1c3d5121">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga497c57551529e8721861cedc1c3d5121"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga5cc57f71faadc4101e7a10e0b5d7317f">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga5cc57f71faadc4101e7a10e0b5d7317f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga66608a108aa332faf3c3bfd418655fcb">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga66608a108aa332faf3c3bfd418655fcb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaee9534127cddea3f7b3e5461f768a42b">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gaee9534127cddea3f7b3e5461f768a42b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga259c308cca0572400aaed34384eafbe3">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga259c308cca0572400aaed34384eafbe3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga56f7d4d8f86928edb83e1f65702a2978">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga56f7d4d8f86928edb83e1f65702a2978"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaa0d89783277d6e9dede11eda2ff6c75a">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor0&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gaa0d89783277d6e9dede11eda2ff6c75a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga20b2c11c8fb2a9e0bb86ad4c66c9c2e7">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga20b2c11c8fb2a9e0bb86ad4c66c9c2e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga8ef4b45b1dcecb9270562c030e38e339">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga8ef4b45b1dcecb9270562c030e38e339"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaa3c16c17557fcebdd7573fa6b2ed0dcf">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gaa3c16c17557fcebdd7573fa6b2ed0dcf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga6bbf2084c41ca86d2ab99e21adf28f30">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga6bbf2084c41ca86d2ab99e21adf28f30"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga21e843c71a56dba1d507c9a92fad48d1">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga21e843c71a56dba1d507c9a92fad48d1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga5af2a45e22e6f53837fa0b5f9de0ad57">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga5af2a45e22e6f53837fa0b5f9de0ad57"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf8ba948d4075a160a3c887d5bc29fe38">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gaf8ba948d4075a160a3c887d5bc29fe38"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga167fc8e84727e8b465c5f569da18fe7c">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor0&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga167fc8e84727e8b465c5f569da18fe7c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac99d35f92c4859d7ba58c0f8dbee8a59">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gac99d35f92c4859d7ba58c0f8dbee8a59"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafd990e80dc9ec40599b0e66526334ed3">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gafd990e80dc9ec40599b0e66526334ed3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga8df64a5ef08edf9a3bffd45888cf6566">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga8df64a5ef08edf9a3bffd45888cf6566"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga115420b91c53ff373128c8d9c5389e26">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga115420b91c53ff373128c8d9c5389e26"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga59db8f4f6bf774aac7a42e4db22fe525">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga59db8f4f6bf774aac7a42e4db22fe525"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4fe42d39978e3534528e704a2ef69d19">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga4fe42d39978e3534528e704a2ef69d19"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaed1e318f76b0b4560f7f7f15348bf74f">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gaed1e318f76b0b4560f7f7f15348bf74f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga7f0b3a137305d0da984cfcaa69028645">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga7f0b3a137305d0da984cfcaa69028645"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafa45bea25d6b97dd4215c61845eb276b">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gafa45bea25d6b97dd4215c61845eb276b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga8bbfab43840801b698deebdbcced31b8">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga8bbfab43840801b698deebdbcced31b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4e8a4b740ba229328323782cdff5defc">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga4e8a4b740ba229328323782cdff5defc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gae32dedba98d5616ffed3bf45564b5925">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gae32dedba98d5616ffed3bf45564b5925"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga0a7438643be599bd0687c6de6af6ec2b">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga0a7438643be599bd0687c6de6af6ec2b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gacb29a90ac86fe224d4074619e0117cb8">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gacb29a90ac86fe224d4074619e0117cb8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaaa2493ee4790a02fad2dfd44e3e4e1f6">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gaaa2493ee4790a02fad2dfd44e3e4e1f6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor0&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gad6f8ec28efe46a939923e0ae83aa2888">sigc::mem_fun0</a> (T_return(T_obj::* _A_func)())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">sigc::mem_functor0</a> which wraps a method. <a href="#gad6f8ec28efe46a939923e0ae83aa2888"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor1&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac54cbcf11289d7b7fe15dff1fc2e84f4">sigc::mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">sigc::mem_functor1</a> which wraps a method. <a href="#gac54cbcf11289d7b7fe15dff1fc2e84f4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor2&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga353bb1c7c03796bafe5ed2e52f012980">sigc::mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">sigc::mem_functor2</a> which wraps a method. <a href="#ga353bb1c7c03796bafe5ed2e52f012980"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor3&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaa603c1c92cc9140a13d89256724de663">sigc::mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">sigc::mem_functor3</a> which wraps a method. <a href="#gaa603c1c92cc9140a13d89256724de663"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor4&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga9e5cce0968f3f2a79240922ebc1b6745">sigc::mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">sigc::mem_functor4</a> which wraps a method. <a href="#ga9e5cce0968f3f2a79240922ebc1b6745"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor5&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab0cbec1f295cbf8283208dedf5ab9ac7">sigc::mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">sigc::mem_functor5</a> which wraps a method. <a href="#gab0cbec1f295cbf8283208dedf5ab9ac7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor6&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1c9c46a46db3d5d01d582b6867665c7c">sigc::mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">sigc::mem_functor6</a> which wraps a method. <a href="#ga1c9c46a46db3d5d01d582b6867665c7c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor7&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafb7d7c8968bebcfea74f08c3eb55b14f">sigc::mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">sigc::mem_functor7</a> which wraps a method. <a href="#gafb7d7c8968bebcfea74f08c3eb55b14f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor0&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gae75bc5b94c36e78775ff5b5f20767baf">sigc::mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. <a href="#gae75bc5b94c36e78775ff5b5f20767baf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor1&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3d62fea84f3f77ac5a315cebe5286b47">sigc::mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. <a href="#ga3d62fea84f3f77ac5a315cebe5286b47"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor2&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gabb30783d2b0ac099089d70274d4459fb">sigc::mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. <a href="#gabb30783d2b0ac099089d70274d4459fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor3&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf19bbb21b4b903e1a6b97fea87e90663">sigc::mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. <a href="#gaf19bbb21b4b903e1a6b97fea87e90663"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor4&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab1a00dd97f2ca5e21b2b4f73fea4053b">sigc::mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. <a href="#gab1a00dd97f2ca5e21b2b4f73fea4053b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor5&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaa34194e868680c9146f8d143ddbdd8a8">sigc::mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. <a href="#gaa34194e868680c9146f8d143ddbdd8a8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor6&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4908458d042d70f91be5f72547518e4f">sigc::mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. <a href="#ga4908458d042d70f91be5f72547518e4f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor7&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga750c42aaea61ec588daf64d4111e8429">sigc::mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. <a href="#ga750c42aaea61ec588daf64d4111e8429"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor0<br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac725cb282b0c611c67a270a7821e173f">sigc::mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. <a href="#gac725cb282b0c611c67a270a7821e173f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor1<br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga211bd1f151b5936a549a8d8e6ab911bf">sigc::mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. <a href="#ga211bd1f151b5936a549a8d8e6ab911bf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor2<br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga55aafe144e22f4df7fe785c1eec839ca">sigc::mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. <a href="#ga55aafe144e22f4df7fe785c1eec839ca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor3<br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3b7fd6101534e982aa29c0308ce69006">sigc::mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. <a href="#ga3b7fd6101534e982aa29c0308ce69006"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor4<br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadedf83e65a2aca0d3aa4ac0b6d68ccd8">sigc::mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. <a href="#gadedf83e65a2aca0d3aa4ac0b6d68ccd8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor5<br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga61cec9d9ec3d399f0d14a3b2edb6fecc">sigc::mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. <a href="#ga61cec9d9ec3d399f0d14a3b2edb6fecc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor6<br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf6a1bce5fc8d6a117124874f2fa6ab18">sigc::mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. <a href="#gaf6a1bce5fc8d6a117124874f2fa6ab18"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor7<br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga208d42856768ebe922a1418f7250ca31">sigc::mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. <a href="#ga208d42856768ebe922a1418f7250ca31"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor0&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga7d9ea809173f48bf5c76cf1989591602">sigc::mem_fun</a> (T_return(T_obj::* _A_func)())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">sigc::mem_functor0</a> which wraps a method. <a href="#ga7d9ea809173f48bf5c76cf1989591602"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor1&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafa7e13948472a451e25485f2c5001028">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">sigc::mem_functor1</a> which wraps a method. <a href="#gafa7e13948472a451e25485f2c5001028"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor2&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga13a02e1edfe8b4450aba9f9629c69183">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">sigc::mem_functor2</a> which wraps a method. <a href="#ga13a02e1edfe8b4450aba9f9629c69183"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor3&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga8a171185d53c5ef87adb18bdd1d34aca">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">sigc::mem_functor3</a> which wraps a method. <a href="#ga8a171185d53c5ef87adb18bdd1d34aca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor4&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga17d792c86d3251c2045987c4dec04494">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">sigc::mem_functor4</a> which wraps a method. <a href="#ga17d792c86d3251c2045987c4dec04494"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor5&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga72ce5f7bfd24897f48d0ebd676bcbe5a">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">sigc::mem_functor5</a> which wraps a method. <a href="#ga72ce5f7bfd24897f48d0ebd676bcbe5a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor6&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadbb4cac2850f0f61f6d5f9e17e02c7ba">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">sigc::mem_functor6</a> which wraps a method. <a href="#gadbb4cac2850f0f61f6d5f9e17e02c7ba"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">mem_functor7&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf995826321b8808ce8839e4abbb0550d">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">sigc::mem_functor7</a> which wraps a method. <a href="#gaf995826321b8808ce8839e4abbb0550d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor0&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga51fa4e5052666f6738abbaa628ec6cc2">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. <a href="#ga51fa4e5052666f6738abbaa628ec6cc2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor1&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gae53b7ef4bd43363998aff8a589bc254a">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. <a href="#gae53b7ef4bd43363998aff8a589bc254a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor2&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga47ec248386b6998e5f8b9a80191e4d5d">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. <a href="#ga47ec248386b6998e5f8b9a80191e4d5d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor3&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga6e58e3cf7e4f1b5fbcb85736369d018c">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. <a href="#ga6e58e3cf7e4f1b5fbcb85736369d018c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor4&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1b200788ce261aef52a8dadaa1e2c9aa">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. <a href="#ga1b200788ce261aef52a8dadaa1e2c9aa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor5&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga81b830d633d756ca945bac75c4b2f8e8">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. <a href="#ga81b830d633d756ca945bac75c4b2f8e8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor6&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga975cacf1b6fdd69a93c2f5ba0973f780">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. <a href="#ga975cacf1b6fdd69a93c2f5ba0973f780"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor7&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab37fdbceea44a66560bb16345e1593e6">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. <a href="#gab37fdbceea44a66560bb16345e1593e6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor0<br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadd76171e23f2e904c7f01264228440fc">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. <a href="#gadd76171e23f2e904c7f01264228440fc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor1<br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga23120ad94420b72a8761423c5bab2bec">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. <a href="#ga23120ad94420b72a8761423c5bab2bec"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor2<br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga34e7257908fb33b2582f686ac51e1d74">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. <a href="#ga34e7257908fb33b2582f686ac51e1d74"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor3<br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac41f442c5e8a533e98cce0d7df02efe6">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. <a href="#gac41f442c5e8a533e98cce0d7df02efe6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor4<br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab1b6c289aa5b68e382c259bb5c35aa95">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. <a href="#gab1b6c289aa5b68e382c259bb5c35aa95"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor5<br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga8fbf4b5621eda8f79ba2be75bd7badd4">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. <a href="#ga8fbf4b5621eda8f79ba2be75bd7badd4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor6<br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafc3676e579d8e7b037c0589b2ab12270">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. <a href="#gafc3676e579d8e7b037c0589b2ab12270"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bound_const_mem_functor7<br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gacdcec06e66f0ba9a970e530c953d60b6">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. <a href="#gacdcec06e66f0ba9a970e530c953d60b6"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="group__mem__fun.html#ga7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">mem_fun()</a> is used to convert a pointer to a method to a functor. </p>
<p>Optionally a reference or pointer to an object can be bound to the functor. Note that only if the object type inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a> the <a class="el" href="classsigc_1_1slot.html" title="Convenience wrapper for the numbered sigc::slot# templates.">slot</a> is cleared automatically when the object goes out of scope!</p>
<p>If the member function pointer is to an overloaded type, you must specify the types using template arguments starting with the first argument. It is not necessary to supply the return type.</p>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>foo : <span class="keyword">public</span> sigc::trackable
   {
     <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>) {}
   };
   foo my_foo;
   <a class="code" href="classsigc_1_1slot.html" title="Convenience wrapper for the numbered sigc::slot# templates.">sigc::slot&lt;void, int&gt;</a> sl = <a class="code" href="group__mem__fun.html#ga7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun</a>(my_foo, &amp;foo::bar);
</pre></div></dd></dl>
<p>For const methods <a class="el" href="group__mem__fun.html#ga7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">mem_fun()</a> takes a const reference or pointer to an object.</p>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>foo : <span class="keyword">public</span> sigc::trackable
   {
     <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>)<span class="keyword"> const </span>{}
   };
   <span class="keyword">const</span> foo my_foo;
   <a class="code" href="classsigc_1_1slot.html" title="Convenience wrapper for the numbered sigc::slot# templates.">sigc::slot&lt;void, int&gt;</a> sl = <a class="code" href="group__mem__fun.html#ga7d9ea809173f48bf5c76cf1989591602" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun</a>(my_foo, &amp;foo::bar);
</pre></div></dd></dl>
<p>Use mem_fun#() if there is an abiguity as to the number of arguments.</p>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>foo : <span class="keyword">public</span> sigc::trackable
   {
     <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>) {}
     <span class="keywordtype">void</span> bar(<span class="keywordtype">float</span>) {}
     <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>) {}
   };
   foo my_foo;
   <a class="code" href="classsigc_1_1slot.html" title="Convenience wrapper for the numbered sigc::slot# templates.">sigc::slot&lt;void, int&gt;</a> sl = sigc::mem_fun1&lt;int&gt;(my_foo, &amp;foo::bar);
</pre></div> </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gacdcec06e66f0ba9a970e530c953d60b6"></a><!-- doxytag: member="sigc::mem_fun" ref="gacdcec06e66f0ba9a970e530c953d60b6" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc3676e579d8e7b037c0589b2ab12270"></a><!-- doxytag: member="sigc::mem_fun" ref="gafc3676e579d8e7b037c0589b2ab12270" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8fbf4b5621eda8f79ba2be75bd7badd4"></a><!-- doxytag: member="sigc::mem_fun" ref="ga8fbf4b5621eda8f79ba2be75bd7badd4" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab1b6c289aa5b68e382c259bb5c35aa95"></a><!-- doxytag: member="sigc::mem_fun" ref="gab1b6c289aa5b68e382c259bb5c35aa95" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gac41f442c5e8a533e98cce0d7df02efe6"></a><!-- doxytag: member="sigc::mem_fun" ref="gac41f442c5e8a533e98cce0d7df02efe6" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga34e7257908fb33b2582f686ac51e1d74"></a><!-- doxytag: member="sigc::mem_fun" ref="ga34e7257908fb33b2582f686ac51e1d74" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga23120ad94420b72a8761423c5bab2bec"></a><!-- doxytag: member="sigc::mem_fun" ref="ga23120ad94420b72a8761423c5bab2bec" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gadd76171e23f2e904c7f01264228440fc"></a><!-- doxytag: member="sigc::mem_fun" ref="gadd76171e23f2e904c7f01264228440fc" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)() const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab37fdbceea44a66560bb16345e1593e6"></a><!-- doxytag: member="sigc::mem_fun" ref="gab37fdbceea44a66560bb16345e1593e6" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an...">sigc::bound_volatile_mem_functor7</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) ) { return bound_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; mem_fun(/* </p>

</div>
</div>
<a class="anchor" id="ga975cacf1b6fdd69a93c2f5ba0973f780"></a><!-- doxytag: member="sigc::mem_fun" ref="ga975cacf1b6fdd69a93c2f5ba0973f780" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an...">sigc::bound_volatile_mem_functor6</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) ) { return bound_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; mem_fun(/* </p>

</div>
</div>
<a class="anchor" id="ga81b830d633d756ca945bac75c4b2f8e8"></a><!-- doxytag: member="sigc::mem_fun" ref="ga81b830d633d756ca945bac75c4b2f8e8" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an...">sigc::bound_volatile_mem_functor5</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) ) { return bound_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; mem_fun(/* </p>

</div>
</div>
<a class="anchor" id="ga1b200788ce261aef52a8dadaa1e2c9aa"></a><!-- doxytag: member="sigc::mem_fun" ref="ga1b200788ce261aef52a8dadaa1e2c9aa" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an...">sigc::bound_volatile_mem_functor4</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4) ) { return bound_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; mem_fun(/* </p>

</div>
</div>
<a class="anchor" id="ga6e58e3cf7e4f1b5fbcb85736369d018c"></a><!-- doxytag: member="sigc::mem_fun" ref="ga6e58e3cf7e4f1b5fbcb85736369d018c" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an...">sigc::bound_volatile_mem_functor3</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3) ) { return bound_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; mem_fun(/* </p>

</div>
</div>
<a class="anchor" id="ga47ec248386b6998e5f8b9a80191e4d5d"></a><!-- doxytag: member="sigc::mem_fun" ref="ga47ec248386b6998e5f8b9a80191e4d5d" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an...">sigc::bound_volatile_mem_functor2</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1, T_arg2) ) { return bound_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt; mem_fun(/* </p>

</div>
</div>
<a class="anchor" id="gae53b7ef4bd43363998aff8a589bc254a"></a><!-- doxytag: member="sigc::mem_fun" ref="gae53b7ef4bd43363998aff8a589bc254a" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an...">sigc::bound_volatile_mem_functor1</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) ) { return bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun(/* </p>

</div>
</div>
<a class="anchor" id="ga51fa4e5052666f6738abbaa628ec6cc2"></a><!-- doxytag: member="sigc::mem_fun" ref="ga51fa4e5052666f6738abbaa628ec6cc2" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)()&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an...">sigc::bound_volatile_mem_functor0</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() ) { return bound_mem_functor0&lt;T_return, T_obj&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor0&lt;T_return, T_obj&gt; mem_fun(/* </p>

</div>
</div>
<a class="anchor" id="gaf995826321b8808ce8839e4abbb0550d"></a><!-- doxytag: member="sigc::mem_fun" ref="gaf995826321b8808ce8839e4abbb0550d" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">sigc::mem_functor7</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html" title="const_volatile_mem_functor7 wraps const volatile methods with 7 argument(s).">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor7.html" title="volatile_mem_functor7 wraps volatile methods with 7 argument(s).">sigc::volatile_mem_functor7</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor7.html" title="const_mem_functor7 wraps const methods with 7 argument(s).">sigc::const_mem_functor7</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gadbb4cac2850f0f61f6d5f9e17e02c7ba"></a><!-- doxytag: member="sigc::mem_fun" ref="gadbb4cac2850f0f61f6d5f9e17e02c7ba" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">sigc::mem_functor6</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html" title="const_volatile_mem_functor6 wraps const volatile methods with 6 argument(s).">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor6.html" title="volatile_mem_functor6 wraps volatile methods with 6 argument(s).">sigc::volatile_mem_functor6</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor6.html" title="const_mem_functor6 wraps const methods with 6 argument(s).">sigc::const_mem_functor6</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga72ce5f7bfd24897f48d0ebd676bcbe5a"></a><!-- doxytag: member="sigc::mem_fun" ref="ga72ce5f7bfd24897f48d0ebd676bcbe5a" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">sigc::mem_functor5</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html" title="const_volatile_mem_functor5 wraps const volatile methods with 5 argument(s).">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor5.html" title="volatile_mem_functor5 wraps volatile methods with 5 argument(s).">sigc::volatile_mem_functor5</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor5.html" title="const_mem_functor5 wraps const methods with 5 argument(s).">sigc::const_mem_functor5</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga17d792c86d3251c2045987c4dec04494"></a><!-- doxytag: member="sigc::mem_fun" ref="ga17d792c86d3251c2045987c4dec04494" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">sigc::mem_functor4</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html" title="const_volatile_mem_functor4 wraps const volatile methods with 4 argument(s).">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor4.html" title="volatile_mem_functor4 wraps volatile methods with 4 argument(s).">sigc::volatile_mem_functor4</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor4.html" title="const_mem_functor4 wraps const methods with 4 argument(s).">sigc::const_mem_functor4</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a171185d53c5ef87adb18bdd1d34aca"></a><!-- doxytag: member="sigc::mem_fun" ref="ga8a171185d53c5ef87adb18bdd1d34aca" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">sigc::mem_functor3</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html" title="const_volatile_mem_functor3 wraps const volatile methods with 3 argument(s).">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor3.html" title="volatile_mem_functor3 wraps volatile methods with 3 argument(s).">sigc::volatile_mem_functor3</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor3.html" title="const_mem_functor3 wraps const methods with 3 argument(s).">sigc::const_mem_functor3</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga13a02e1edfe8b4450aba9f9629c69183"></a><!-- doxytag: member="sigc::mem_fun" ref="ga13a02e1edfe8b4450aba9f9629c69183" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">sigc::mem_functor2</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html" title="const_volatile_mem_functor2 wraps const volatile methods with 2 argument(s).">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor2.html" title="volatile_mem_functor2 wraps volatile methods with 2 argument(s).">sigc::volatile_mem_functor2</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor2.html" title="const_mem_functor2 wraps const methods with 2 argument(s).">sigc::const_mem_functor2</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gafa7e13948472a451e25485f2c5001028"></a><!-- doxytag: member="sigc::mem_fun" ref="gafa7e13948472a451e25485f2c5001028" args="(T_return(T_obj::*_A_func)(T_arg1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">sigc::mem_functor1</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html" title="const_volatile_mem_functor1 wraps const volatile methods with 1 argument(s).">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor1.html" title="volatile_mem_functor1 wraps volatile methods with 1 argument(s).">sigc::volatile_mem_functor1</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor1.html" title="const_mem_functor1 wraps const methods with 1 argument(s).">sigc::const_mem_functor1</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d9ea809173f48bf5c76cf1989591602"></a><!-- doxytag: member="sigc::mem_fun" ref="ga7d9ea809173f48bf5c76cf1989591602" args="(T_return(T_obj::*_A_func)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)()&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">sigc::mem_functor0</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html" title="const_volatile_mem_functor0 wraps const volatile methods with 0 argument(s).">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor0.html" title="volatile_mem_functor0 wraps volatile methods with 0 argument(s).">sigc::volatile_mem_functor0</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor0.html" title="const_mem_functor0 wraps const methods with 0 argument(s).">sigc::const_mem_functor0</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gac725cb282b0c611c67a270a7821e173f"></a><!-- doxytag: member="sigc::mem_fun0" ref="gac725cb282b0c611c67a270a7821e173f" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)() const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gae75bc5b94c36e78775ff5b5f20767baf"></a><!-- doxytag: member="sigc::mem_fun0" ref="gae75bc5b94c36e78775ff5b5f20767baf" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)()&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an...">sigc::bound_volatile_mem_functor0</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)() ) { return bound_mem_functor0&lt;T_return, T_obj&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor0&lt;T_return, T_obj&gt; mem_fun0(/* </p>

</div>
</div>
<a class="anchor" id="gad6f8ec28efe46a939923e0ae83aa2888"></a><!-- doxytag: member="sigc::mem_fun0" ref="gad6f8ec28efe46a939923e0ae83aa2888" args="(T_return(T_obj::*_A_func)())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)()&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">sigc::mem_functor0</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html" title="const_volatile_mem_functor0 wraps const volatile methods with 0 argument(s).">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor0.html" title="volatile_mem_functor0 wraps volatile methods with 0 argument(s).">sigc::volatile_mem_functor0</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor0.html" title="const_mem_functor0 wraps const methods with 0 argument(s).">sigc::const_mem_functor0</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga211bd1f151b5936a549a8d8e6ab911bf"></a><!-- doxytag: member="sigc::mem_fun1" ref="ga211bd1f151b5936a549a8d8e6ab911bf" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d62fea84f3f77ac5a315cebe5286b47"></a><!-- doxytag: member="sigc::mem_fun1" ref="ga3d62fea84f3f77ac5a315cebe5286b47" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an...">sigc::bound_volatile_mem_functor1</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1) ) { return bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor1&lt;T_return, T_obj, T_arg1&gt; mem_fun1(/* </p>

</div>
</div>
<a class="anchor" id="gac54cbcf11289d7b7fe15dff1fc2e84f4"></a><!-- doxytag: member="sigc::mem_fun1" ref="gac54cbcf11289d7b7fe15dff1fc2e84f4" args="(T_return(T_obj::*_A_func)(T_arg1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">sigc::mem_functor1</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html" title="const_volatile_mem_functor1 wraps const volatile methods with 1 argument(s).">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor1.html" title="volatile_mem_functor1 wraps volatile methods with 1 argument(s).">sigc::volatile_mem_functor1</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor1.html" title="const_mem_functor1 wraps const methods with 1 argument(s).">sigc::const_mem_functor1</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga55aafe144e22f4df7fe785c1eec839ca"></a><!-- doxytag: member="sigc::mem_fun2" ref="ga55aafe144e22f4df7fe785c1eec839ca" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gabb30783d2b0ac099089d70274d4459fb"></a><!-- doxytag: member="sigc::mem_fun2" ref="gabb30783d2b0ac099089d70274d4459fb" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an...">sigc::bound_volatile_mem_functor2</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1, T_arg2) ) { return bound_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor2&lt;T_return, T_obj, T_arg1, T_arg2&gt; mem_fun2(/* </p>

</div>
</div>
<a class="anchor" id="ga353bb1c7c03796bafe5ed2e52f012980"></a><!-- doxytag: member="sigc::mem_fun2" ref="ga353bb1c7c03796bafe5ed2e52f012980" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">sigc::mem_functor2</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html" title="const_volatile_mem_functor2 wraps const volatile methods with 2 argument(s).">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor2.html" title="volatile_mem_functor2 wraps volatile methods with 2 argument(s).">sigc::volatile_mem_functor2</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor2.html" title="const_mem_functor2 wraps const methods with 2 argument(s).">sigc::const_mem_functor2</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3b7fd6101534e982aa29c0308ce69006"></a><!-- doxytag: member="sigc::mem_fun3" ref="ga3b7fd6101534e982aa29c0308ce69006" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf19bbb21b4b903e1a6b97fea87e90663"></a><!-- doxytag: member="sigc::mem_fun3" ref="gaf19bbb21b4b903e1a6b97fea87e90663" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an...">sigc::bound_volatile_mem_functor3</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3) ) { return bound_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor3&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; mem_fun3(/* </p>

</div>
</div>
<a class="anchor" id="gaa603c1c92cc9140a13d89256724de663"></a><!-- doxytag: member="sigc::mem_fun3" ref="gaa603c1c92cc9140a13d89256724de663" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">sigc::mem_functor3</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html" title="const_volatile_mem_functor3 wraps const volatile methods with 3 argument(s).">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor3.html" title="volatile_mem_functor3 wraps volatile methods with 3 argument(s).">sigc::volatile_mem_functor3</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor3.html" title="const_mem_functor3 wraps const methods with 3 argument(s).">sigc::const_mem_functor3</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gadedf83e65a2aca0d3aa4ac0b6d68ccd8"></a><!-- doxytag: member="sigc::mem_fun4" ref="gadedf83e65a2aca0d3aa4ac0b6d68ccd8" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab1a00dd97f2ca5e21b2b4f73fea4053b"></a><!-- doxytag: member="sigc::mem_fun4" ref="gab1a00dd97f2ca5e21b2b4f73fea4053b" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an...">sigc::bound_volatile_mem_functor4</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4) ) { return bound_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor4&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; mem_fun4(/* </p>

</div>
</div>
<a class="anchor" id="ga9e5cce0968f3f2a79240922ebc1b6745"></a><!-- doxytag: member="sigc::mem_fun4" ref="ga9e5cce0968f3f2a79240922ebc1b6745" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">sigc::mem_functor4</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html" title="const_volatile_mem_functor4 wraps const volatile methods with 4 argument(s).">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor4.html" title="volatile_mem_functor4 wraps volatile methods with 4 argument(s).">sigc::volatile_mem_functor4</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor4.html" title="const_mem_functor4 wraps const methods with 4 argument(s).">sigc::const_mem_functor4</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga61cec9d9ec3d399f0d14a3b2edb6fecc"></a><!-- doxytag: member="sigc::mem_fun5" ref="ga61cec9d9ec3d399f0d14a3b2edb6fecc" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa34194e868680c9146f8d143ddbdd8a8"></a><!-- doxytag: member="sigc::mem_fun5" ref="gaa34194e868680c9146f8d143ddbdd8a8" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an...">sigc::bound_volatile_mem_functor5</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) ) { return bound_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor5&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; mem_fun5(/* </p>

</div>
</div>
<a class="anchor" id="gab0cbec1f295cbf8283208dedf5ab9ac7"></a><!-- doxytag: member="sigc::mem_fun5" ref="gab0cbec1f295cbf8283208dedf5ab9ac7" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">sigc::mem_functor5</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html" title="const_volatile_mem_functor5 wraps const volatile methods with 5 argument(s).">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor5.html" title="volatile_mem_functor5 wraps volatile methods with 5 argument(s).">sigc::volatile_mem_functor5</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor5.html" title="const_mem_functor5 wraps const methods with 5 argument(s).">sigc::const_mem_functor5</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6a1bce5fc8d6a117124874f2fa6ab18"></a><!-- doxytag: member="sigc::mem_fun6" ref="gaf6a1bce5fc8d6a117124874f2fa6ab18" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4908458d042d70f91be5f72547518e4f"></a><!-- doxytag: member="sigc::mem_fun6" ref="ga4908458d042d70f91be5f72547518e4f" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an...">sigc::bound_volatile_mem_functor6</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) ) { return bound_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor6&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; mem_fun6(/* </p>

</div>
</div>
<a class="anchor" id="ga1c9c46a46db3d5d01d582b6867665c7c"></a><!-- doxytag: member="sigc::mem_fun6" ref="ga1c9c46a46db3d5d01d582b6867665c7c" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">sigc::mem_functor6</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html" title="const_volatile_mem_functor6 wraps const volatile methods with 6 argument(s).">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor6.html" title="volatile_mem_functor6 wraps volatile methods with 6 argument(s).">sigc::volatile_mem_functor6</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor6.html" title="const_mem_functor6 wraps const methods with 6 argument(s).">sigc::const_mem_functor6</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga208d42856768ebe922a1418f7250ca31"></a><!-- doxytag: member="sigc::mem_fun7" ref="ga208d42856768ebe922a1418f7250ca31" args="(T_obj *_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga750c42aaea61ec588daf64d4111e8429"></a><!-- doxytag: member="sigc::mem_fun7" ref="ga750c42aaea61ec588daf64d4111e8429" args="(T_obj &amp;_A_obj, T_return(T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"> <em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an...">sigc::bound_volatile_mem_functor7</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_obj</em>&#160;</td><td>/ T_obj* _A_obj, T_return (T_obj2::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) ) { return bound_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;(_A_obj, _A_func); }</td></tr>
  </table>
  </dd>
</dl>
<p>template &lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; inline bound_mem_functor7&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; mem_fun7(/* </p>

</div>
</div>
<a class="anchor" id="gafb7d7c8968bebcfea74f08c3eb55b14f"></a><!-- doxytag: member="sigc::mem_fun7" ref="gafb7d7c8968bebcfea74f08c3eb55b14f" args="(T_return(T_obj::*_A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"> <em>_A_func</em></td>
          <td>&#160;)&#160;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">sigc::mem_functor7</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html" title="const_volatile_mem_functor7 wraps const volatile methods with 7 argument(s).">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor7.html" title="volatile_mem_functor7 wraps volatile methods with 7 argument(s).">sigc::volatile_mem_functor7</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor7.html" title="const_mem_functor7 wraps const methods with 7 argument(s).">sigc::const_mem_functor7</a> which wraps a const method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_func</em>&#160;</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaa2493ee4790a02fad2dfd44e3e4e1f6"></a><!-- doxytag: member="sigc::visit_each" ref="gaaa2493ee4790a02fad2dfd44e3e4e1f6" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gacb29a90ac86fe224d4074619e0117cb8"></a><!-- doxytag: member="sigc::visit_each" ref="gacb29a90ac86fe224d4074619e0117cb8" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga0a7438643be599bd0687c6de6af6ec2b"></a><!-- doxytag: member="sigc::visit_each" ref="ga0a7438643be599bd0687c6de6af6ec2b" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gae32dedba98d5616ffed3bf45564b5925"></a><!-- doxytag: member="sigc::visit_each" ref="gae32dedba98d5616ffed3bf45564b5925" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga4e8a4b740ba229328323782cdff5defc"></a><!-- doxytag: member="sigc::visit_each" ref="ga4e8a4b740ba229328323782cdff5defc" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga8bbfab43840801b698deebdbcced31b8"></a><!-- doxytag: member="sigc::visit_each" ref="ga8bbfab43840801b698deebdbcced31b8" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gafa45bea25d6b97dd4215c61845eb276b"></a><!-- doxytag: member="sigc::visit_each" ref="gafa45bea25d6b97dd4215c61845eb276b" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga7f0b3a137305d0da984cfcaa69028645"></a><!-- doxytag: member="sigc::visit_each" ref="ga7f0b3a137305d0da984cfcaa69028645" args="(const T_action &amp;_A_action, const bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gaed1e318f76b0b4560f7f7f15348bf74f"></a><!-- doxytag: member="sigc::visit_each" ref="gaed1e318f76b0b4560f7f7f15348bf74f" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga4fe42d39978e3534528e704a2ef69d19"></a><!-- doxytag: member="sigc::visit_each" ref="ga4fe42d39978e3534528e704a2ef69d19" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga59db8f4f6bf774aac7a42e4db22fe525"></a><!-- doxytag: member="sigc::visit_each" ref="ga59db8f4f6bf774aac7a42e4db22fe525" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga115420b91c53ff373128c8d9c5389e26"></a><!-- doxytag: member="sigc::visit_each" ref="ga115420b91c53ff373128c8d9c5389e26" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga8df64a5ef08edf9a3bffd45888cf6566"></a><!-- doxytag: member="sigc::visit_each" ref="ga8df64a5ef08edf9a3bffd45888cf6566" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gafd990e80dc9ec40599b0e66526334ed3"></a><!-- doxytag: member="sigc::visit_each" ref="gafd990e80dc9ec40599b0e66526334ed3" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gac99d35f92c4859d7ba58c0f8dbee8a59"></a><!-- doxytag: member="sigc::visit_each" ref="gac99d35f92c4859d7ba58c0f8dbee8a59" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga167fc8e84727e8b465c5f569da18fe7c"></a><!-- doxytag: member="sigc::visit_each" ref="ga167fc8e84727e8b465c5f569da18fe7c" args="(const T_action &amp;_A_action, const bound_volatile_mem_functor0&lt; T_return, T_obj &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor0&lt; T_return, T_obj &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gaf8ba948d4075a160a3c887d5bc29fe38"></a><!-- doxytag: member="sigc::visit_each" ref="gaf8ba948d4075a160a3c887d5bc29fe38" args="(const T_action &amp;_A_action, const bound_const_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga5af2a45e22e6f53837fa0b5f9de0ad57"></a><!-- doxytag: member="sigc::visit_each" ref="ga5af2a45e22e6f53837fa0b5f9de0ad57" args="(const T_action &amp;_A_action, const bound_const_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga21e843c71a56dba1d507c9a92fad48d1"></a><!-- doxytag: member="sigc::visit_each" ref="ga21e843c71a56dba1d507c9a92fad48d1" args="(const T_action &amp;_A_action, const bound_const_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga6bbf2084c41ca86d2ab99e21adf28f30"></a><!-- doxytag: member="sigc::visit_each" ref="ga6bbf2084c41ca86d2ab99e21adf28f30" args="(const T_action &amp;_A_action, const bound_const_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gaa3c16c17557fcebdd7573fa6b2ed0dcf"></a><!-- doxytag: member="sigc::visit_each" ref="gaa3c16c17557fcebdd7573fa6b2ed0dcf" args="(const T_action &amp;_A_action, const bound_const_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga8ef4b45b1dcecb9270562c030e38e339"></a><!-- doxytag: member="sigc::visit_each" ref="ga8ef4b45b1dcecb9270562c030e38e339" args="(const T_action &amp;_A_action, const bound_const_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga20b2c11c8fb2a9e0bb86ad4c66c9c2e7"></a><!-- doxytag: member="sigc::visit_each" ref="ga20b2c11c8fb2a9e0bb86ad4c66c9c2e7" args="(const T_action &amp;_A_action, const bound_const_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gaa0d89783277d6e9dede11eda2ff6c75a"></a><!-- doxytag: member="sigc::visit_each" ref="gaa0d89783277d6e9dede11eda2ff6c75a" args="(const T_action &amp;_A_action, const bound_const_mem_functor0&lt; T_return, T_obj &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor0&lt; T_return, T_obj &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga56f7d4d8f86928edb83e1f65702a2978"></a><!-- doxytag: member="sigc::visit_each" ref="ga56f7d4d8f86928edb83e1f65702a2978" args="(const T_action &amp;_A_action, const bound_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga259c308cca0572400aaed34384eafbe3"></a><!-- doxytag: member="sigc::visit_each" ref="ga259c308cca0572400aaed34384eafbe3" args="(const T_action &amp;_A_action, const bound_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gaee9534127cddea3f7b3e5461f768a42b"></a><!-- doxytag: member="sigc::visit_each" ref="gaee9534127cddea3f7b3e5461f768a42b" args="(const T_action &amp;_A_action, const bound_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga66608a108aa332faf3c3bfd418655fcb"></a><!-- doxytag: member="sigc::visit_each" ref="ga66608a108aa332faf3c3bfd418655fcb" args="(const T_action &amp;_A_action, const bound_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga5cc57f71faadc4101e7a10e0b5d7317f"></a><!-- doxytag: member="sigc::visit_each" ref="ga5cc57f71faadc4101e7a10e0b5d7317f" args="(const T_action &amp;_A_action, const bound_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga497c57551529e8721861cedc1c3d5121"></a><!-- doxytag: member="sigc::visit_each" ref="ga497c57551529e8721861cedc1c3d5121" args="(const T_action &amp;_A_action, const bound_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gaff3264460325cf2a34cc0502fec7b8b7"></a><!-- doxytag: member="sigc::visit_each" ref="gaff3264460325cf2a34cc0502fec7b8b7" args="(const T_action &amp;_A_action, const bound_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga8a0e4bdca79dde7347318bff4d6e1eda"></a><!-- doxytag: member="sigc::visit_each" ref="ga8a0e4bdca79dde7347318bff4d6e1eda" args="(const T_action &amp;_A_action, const bound_mem_functor0&lt; T_return, T_obj &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor0&lt; T_return, T_obj &gt; &amp;&#160;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Jun 4 16:11:33 2010 for libsigc++ by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
