<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libsigc++: Functors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsigc++
   &#160;<span id="projectnumber">2.10.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functors</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functors are copyable types that define operator()().  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__slot"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slot.html">Slots</a></td></tr>
<tr class="memdesc:group__slot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slots are type-safe representations of callback methods and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__mem__fun"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mem__fun.html">mem_fun()</a></td></tr>
<tr class="memdesc:group__mem__fun"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__mem__fun.html#gadf6b6d22c503b439019f0a2e77352419" title="Creates a functor of type sigc::mem_functor0 which wraps a method. ">mem_fun()</a> Creates a functor from a pointer to a method. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__ptr__fun"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html">ptr_fun()</a></td></tr>
<tr class="memdesc:group__ptr__fun"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__ptr__fun.html#ga9c80de72f656fb05e81fda622dddc863" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member function...">ptr_fun()</a> is used to convert a pointer to a function to a functor. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1can__deduce__result__type__with__decltype.html">sigc::can_deduce_result_type_with_decltype&lt; T_functor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class, to determine if decltype() can deduce the result type of a functor.  <a href="classsigc_1_1can__deduce__result__type__with__decltype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__base.html">sigc::functor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hint to the compiler.  <a href="structsigc_1_1functor__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait.html">sigc::functor_trait&lt; T_functor, I_derives_functor_base, I_can_use_decltype &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait that specifies the return type of any type.  <a href="structsigc_1_1functor__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1visitor.html">sigc::visitor&lt; T_functor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsigc_1_1visitor.html#a9fe5d6be845e622a99a0db5d3621d4b3">sigc::visitor&lt;T_functor&gt;::do_visit_each()</a> performs a functor on each of the targets of a functor.  <a href="structsigc_1_1visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7a6f5575dc0b0ea896889c782721f6be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#ga7a6f5575dc0b0ea896889c782721f6be">SIGC_FUNCTOR_TRAIT</a>(T_functor,  T_return)</td></tr>
<tr class="memdesc:ga7a6f5575dc0b0ea896889c782721f6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro, if you want to mix user-defined and third party functors with libsigc++.  <a href="#ga7a6f5575dc0b0ea896889c782721f6be">More...</a><br /></td></tr>
<tr class="separator:ga7a6f5575dc0b0ea896889c782721f6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf1ba3cacb09cc5c3c3e399836ec6e50"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#gadf1ba3cacb09cc5c3c3e399836ec6e50">SIGC_FUNCTORS_DEDUCE_RESULT_TYPE_WITH_DECLTYPE</a></td></tr>
<tr class="memdesc:gadf1ba3cacb09cc5c3c3e399836ec6e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro, if you want to mix user-defined and third party functors with libsigc++.  <a href="#gadf1ba3cacb09cc5c3c3e399836ec6e50">More...</a><br /></td></tr>
<tr class="separator:gadf1ba3cacb09cc5c3c3e399836ec6e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b6ee8815d90adccfdceed72bcda577"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#ga93b6ee8815d90adccfdceed72bcda577">SIGC_FUNCTORS_HAVE_RESULT_TYPE</a></td></tr>
<tr class="memdesc:ga93b6ee8815d90adccfdceed72bcda577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro, if you want to mix user-defined and third party functors with libsigc++.  <a href="#ga93b6ee8815d90adccfdceed72bcda577">More...</a><br /></td></tr>
<tr class="separator:ga93b6ee8815d90adccfdceed72bcda577"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor &gt; </td></tr>
<tr class="memitem:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404">sigc::visit_each</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>
<tr class="memdesc:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor.  <a href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404">More...</a><br /></td></tr>
<tr class="separator:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada222d975b87d64cfa7a7f29244ae587"><td class="memTemplParams" colspan="2">template&lt;class T_type , class T_action , class T_functor &gt; </td></tr>
<tr class="memitem:gada222d975b87d64cfa7a7f29244ae587"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#gada222d975b87d64cfa7a7f29244ae587">sigc::visit_each_type</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>
<tr class="memdesc:gada222d975b87d64cfa7a7f29244ae587"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor limited to a restricted type.  <a href="group__sigcfunctors.html#gada222d975b87d64cfa7a7f29244ae587">More...</a><br /></td></tr>
<tr class="separator:gada222d975b87d64cfa7a7f29244ae587"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functors are copyable types that define operator()(). </p>
<p>Types that define operator()() overloads with different return types are referred to as multi-type functors. Multi-type functors are only partially supported in libsigc++.</p>
<p>Closures are functors that store all information needed to invoke a callback from operator()().</p>
<p>Adaptors are functors that alter the signature of a functor's operator()().</p>
<p>libsigc++ defines numerous functors, closures and adaptors. Since libsigc++ is a callback library, most functors are also closures. The documentation doesn't distinguish between functors and closures.</p>
<p>The basic functor types libsigc++ provides are created with <a class="el" href="group__ptr__fun.html#ga9c80de72f656fb05e81fda622dddc863" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member function...">ptr_fun()</a> and <a class="el" href="group__mem__fun.html#gadf6b6d22c503b439019f0a2e77352419" title="Creates a functor of type sigc::mem_functor0 which wraps a method. ">mem_fun()</a> and can be converted into slots implicitly. The set of adaptors that ships with libsigc++ is documented in the <a class="el" href="group__adaptors.html">Adaptors</a> module.</p>
<p>If you want to mix user-defined and third party functors with libsigc++, and you want them to be implicitly convertible into slots, libsigc++ must know the result type of your functors. There are different ways to achieve that.</p>
<ul>
<li>Derive your functors from <a class="el" href="structsigc_1_1functor__base.html" title="A hint to the compiler. ">sigc::functor_base</a> and place <code>typedef T_return result_type;</code> in the class definition.</li>
<li>Use the macro <a class="el" href="group__sigcfunctors.html#ga7a6f5575dc0b0ea896889c782721f6be" title="Helper macro, if you want to mix user-defined and third party functors with libsigc++. ">SIGC_FUNCTOR_TRAIT(T_functor,T_return)</a> in namespace sigc. Multi-type functors are only partly supported.</li>
<li>For functors not derived from <a class="el" href="structsigc_1_1functor__base.html" title="A hint to the compiler. ">sigc::functor_base</a>, and not specified with <a class="el" href="group__sigcfunctors.html#ga7a6f5575dc0b0ea896889c782721f6be" title="Helper macro, if you want to mix user-defined and third party functors with libsigc++. ">SIGC_FUNCTOR_TRAIT()</a>, libsigc++ tries to deduce the result type with the C++11 decltype() specifier. That attempt usually succeeds if the functor has a single operator()(), but it fails if operator()() is overloaded.</li>
<li>Use the macro <a class="el" href="group__sigcfunctors.html#ga93b6ee8815d90adccfdceed72bcda577" title="Helper macro, if you want to mix user-defined and third party functors with libsigc++. ">SIGC_FUNCTORS_HAVE_RESULT_TYPE</a>, if you want libsigc++ to assume that result_type is defined in all user-defined or third party functors, whose result type can't be deduced in any other way.</li>
</ul>
<p>If all these ways to deduce the result type fail, void is assumed.</p>
<p>With libsigc++ versions before 2.6, the macro <a class="el" href="group__sigcfunctors.html#gadf1ba3cacb09cc5c3c3e399836ec6e50" title="Helper macro, if you want to mix user-defined and third party functors with libsigc++. ">SIGC_FUNCTORS_DEDUCE_RESULT_TYPE_WITH_DECLTYPE</a> activated the test with decltype(). That macro is now unneccesary and deprecated. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga7a6f5575dc0b0ea896889c782721f6be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGC_FUNCTOR_TRAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T_functor, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T_return&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro, if you want to mix user-defined and third party functors with libsigc++. </p>
<p>If you want to mix functors not derived from <a class="el" href="structsigc_1_1functor__base.html" title="A hint to the compiler. ">sigc::functor_base</a> with libsigc++, and these functors don't define <code>result_type</code>, use this macro inside namespace sigc to expose the return type of the functors like so: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;namespace sigc {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  SIGC_FUNCTOR_TRAIT(first_functor_type, return_type_of_first_functor_type)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  SIGC_FUNCTOR_TRAIT(second_functor_type, return_type_of_second_functor_type)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  ...</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gadf1ba3cacb09cc5c3c3e399836ec6e50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGC_FUNCTORS_DEDUCE_RESULT_TYPE_WITH_DECLTYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro, if you want to mix user-defined and third party functors with libsigc++. </p>
<p>If you want to mix functors not derived from <a class="el" href="structsigc_1_1functor__base.html" title="A hint to the compiler. ">sigc::functor_base</a> with libsigc++, and your compiler can deduce the result type of the functor with the C++11 keyword <code>decltype</code>, use this macro inside namespace sigc like so: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;namespace sigc {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  SIGC_FUNCTORS_DEDUCE_RESULT_TYPE_WITH_DECLTYPE</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --><p>Functors with overloaded operator()() are not supported.</p>
<dl class="since_2_2_11"><dt><b><a class="el" href="since_2_2_11.html#_since_2_2_11000001">Since libsigc++ 2.2.11:</a></b></dt><dd></dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000069">Deprecated:</a></b></dt><dd>This macro does nothing. The test it activated in libsigc++ versions before 2.6, is now unconditionally activated.</dd></dl>

</div>
</div>
<a class="anchor" id="ga93b6ee8815d90adccfdceed72bcda577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGC_FUNCTORS_HAVE_RESULT_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro, if you want to mix user-defined and third party functors with libsigc++. </p>
<p>If you want to mix functors not derived from <a class="el" href="structsigc_1_1functor__base.html" title="A hint to the compiler. ">sigc::functor_base</a> with libsigc++, and these functors define <code>result_type</code>, use this macro inside namespace sigc like so: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;namespace sigc { SIGC_FUNCTORS_HAVE_RESULT_TYPE }</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga64cb7832acc1e58efb5ffe0b4f5e9404"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_functor &amp;&#160;</td>
          <td class="paramname"><em>_A_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a functor on each of the targets of a functor. </p>

</div>
</div>
<a class="anchor" id="gada222d975b87d64cfa7a7f29244ae587"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type , class T_action , class T_functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each_type </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_functor &amp;&#160;</td>
          <td class="paramname"><em>_A_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a functor on each of the targets of a functor limited to a restricted type. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 12 2019 17:31:14 for libsigc++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
